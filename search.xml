<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>test</title>
      <link href="/2022/05/19/test/"/>
      <url>/2022/05/19/test/</url>
      
        <content type="html"><![CDATA[<p>这是文章的摘要</p><a id="more"></a><p>这是文章的正文</p><p><img src="./test/test.png" class="lazy" data-srcset="./test/test.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="image-20220519193518529"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git 向导</title>
      <link href="/2021/05/05/git-guide/"/>
      <url>/2021/05/05/git-guide/</url>
      
        <content type="html"><![CDATA[<p class="text-danger">© 本文版权归作者Link 所有，转载请注明出处。</p><h2 id="Git-是什么？"><a href="#Git-是什么？" class="headerlink" title="Git 是什么？"></a>Git 是什么？</h2><p><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a> 是一个分布式版本控制系统（<a href="https://en.wikipedia.org/wiki/Distributed_version_control" target="_blank" rel="noopener">Distributed Version Control System</a>），客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。</p><p>四个特点：</p><ul><li>直接记录快照，而非差异比较；</li><li>近乎所有操作都是本地执行；</li><li>Git 保证完整性；</li><li>Git 一般只添加数据；</li></ul><h2 id="Git-的工作流程"><a href="#Git-的工作流程" class="headerlink" title="Git 的工作流程"></a>Git 的工作流程</h2><p><img src="https://img.imgdb.cn/item/60924ef8d1a9ae528f1e4864.jpg" class="lazy" data-srcset="https://img.imgdb.cn/item/60924ef8d1a9ae528f1e4864.jpg" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="git-workflow"></p><p>（Git - Workflow <a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">来源：阮一峰的网络日志</a>）</p><h3 id="专业名词"><a href="#专业名词" class="headerlink" title="专业名词"></a>专业名词</h3><p>基本的 Git 工作流程：</p><ol><li>在工作区（Workspace）中修改文件；</li><li>将更改选择性暂存至暂存区（Staging area/ Index）；</li><li>提交暂存区的内容到本地仓库（Repository）；</li></ol><p>Git 的三种状态，文件可能处于其一，假设这个文件是<code>README.md</code>，那么它为：</p><ul><li><code>modified</code>：修改了文件，但修改仅在<strong>工作区</strong>；</li><li><code>staged</code>：将工作区已修改的文件放到了<strong>暂存区</strong>；</li><li><code>committed</code>：文件已经安全地保存到<strong>本地仓库</strong>。</li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><ol><li>设置提交代码时的用户信息：</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git config [--global] user.name <span class="string">"[name]"</span></span><br><span class="line">$ git config [--global] user.email <span class="string">"[email address]"</span></span><br></pre></td></tr></table></figure><ol start="2"><li>检查设定：</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出当前的 Git 配置</span></span><br><span class="line">$ git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加上 --local, --global, --system 参数可以分别查询该本地仓库，全局，系统的 Git 配置</span></span><br></pre></td></tr></table></figure><p>配置文件的路径：</p><ul><li>本地仓库配置对应的配置文件路径 [–local] ：</li></ul><figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line">&lt;repo&gt;<span class="regexp">/.git/</span>config</span><br></pre></td></tr></table></figure><ul><li>用户全局配置对应的配置文件路径 [–global] ：</li></ul><figure class="highlight haml"><table><tr><td class="code"><pre><span class="line">~/.gitconfig</span><br></pre></td></tr></table></figure><ul><li>系统配置对应的配置文件路径[–system]：</li></ul><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/etc/gi</span>tconfig</span><br></pre></td></tr></table></figure><h3 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h3><h4 id="From-existing-data"><a href="#From-existing-data" class="headerlink" title="From existing data"></a>From existing data</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/my_projet_directory</span><br><span class="line">$ git init</span><br></pre></td></tr></table></figure><h4 id="From-existing-repository"><a href="#From-existing-repository" class="headerlink" title="From existing repository"></a>From existing repository</h4><p>注意：Git 克隆的是远程 Git 仓库的几乎所有数据，不仅仅是最新的版本。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过 SSH</span></span><br><span class="line">$ git <span class="built_in">clone</span> ssh://user@domain.com/repo.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 HTTP</span></span><br><span class="line">$ git <span class="built_in">clone</span> http://domain.com/user/repo.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 git </span></span><br><span class="line">$ git <span class="built_in">clone</span> git://domain.com/user/repo.git</span><br></pre></td></tr></table></figure><h3 id="本地变动-–-git-status"><a href="#本地变动-–-git-status" class="headerlink" title="本地变动 – git status"></a>本地变动 – git status</h3><p>列出哪些文件已被暂存、未被暂存、未被跟踪，即<strong>查看工作目录下的文件处于什么状态</strong>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure><p>添加指定文件到暂存区，即<strong>将该文件放到暂存区</strong>（new file）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add [file]</span><br></pre></td></tr></table></figure><p>也可以用上面的这条指令<strong>来暂存已被跟踪文件的最新修改</strong>（modified）；</p><ul><li>如果对暂存后的文件再次进行修改，之后查询文件状态，那么这时，这个文件将会同时出现在 staging area 和 workspace，因为最新的修改还在工作区，没有暂存，而之前 git add 的版本被暂存了，如果这时提交，那么本地仓库的版本将会是最后一次 git add 的版本，不包含 workspace 中最新的修改。</li></ul><h3 id="本地变动-–-git-diff"><a href="#本地变动-–-git-diff" class="headerlink" title="本地变动 – git diff"></a>本地变动 – git diff</h3><p>列出追踪但尚未暂存的文件更新了哪些部分，即<strong>工作区</strong>和<strong>暂存区</strong>的差异：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff</span><br></pre></td></tr></table></figure><ul><li>注意：<code>git diff</code> 不能显示自从上次提交的所有变化，它只能显示尚未暂存的变化。如果已经把所有修改的内容都暂存了，那么 <code>git diff</code> 不会有任何反馈。</li></ul><p>列出已经暂存，但是没有提交到本地仓库的变化，即<strong>暂存区</strong>和上一个 commit 的差异：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff --cached</span><br><span class="line"><span class="comment"># -- staged 与 --cached 同义</span></span><br></pre></td></tr></table></figure><p>列出<strong>工作区</strong>和上一个 commit 的差异（当前分支最新commit）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff HEAD</span><br></pre></td></tr></table></figure><p><strong>列出两次 commit 之间的差异：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git diff [ID1] [ID2]</span><br></pre></td></tr></table></figure><h3 id="本地变动-–-git-add"><a href="#本地变动-–-git-add" class="headerlink" title="本地变动 – git add"></a>本地变动 – git add</h3><p><strong>添加当前目录的所有文件到暂存区：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add .</span><br></pre></td></tr></table></figure><p>注意：如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。</p><p><strong>对于同一个文件的多处变化，可以实现分次提交：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git add -p [file]</span><br><span class="line"><span class="comment"># -p is short for --patch</span></span><br></pre></td></tr></table></figure><p>可以更好地利用 git commit 的注释功能，使仓库的版本颗粒度更高，可读性更好。</p><p><strong>参考：</strong></p><ul><li><p><a href="https://stackoverflow.com/questions/1085162/commit-only-part-of-a-file-in-git" target="_blank" rel="noopener">stack overflow：Commit only part of a file in Git</a> </p></li><li><p><a href="http://git-scm.com/docs/git-add/zh_HANS-CN" target="_blank" rel="noopener">Git docs：git-add manpage</a></p></li></ul><h3 id="本地变动-–-git-rm"><a href="#本地变动-–-git-rm" class="headerlink" title="本地变动 – git rm"></a>本地变动 – git rm</h3><p><strong>删除工作区文件，并且将这次删除放入暂存区：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rm [file]</span><br></pre></td></tr></table></figure><p><strong>停止追踪指定文件，但该文件会保留在工作区：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rm --cached [file]</span><br></pre></td></tr></table></figure><ul><li>比如删除添加<code>.gitignore</code>文件前错误提交的文件。</li></ul><h3 id="本地变动-–-git-mv"><a href="#本地变动-–-git-mv" class="headerlink" title="本地变动 – git mv"></a>本地变动 – git mv</h3><p>移动文件，并将这个移动放入暂存区（也可以理解为文件改名）：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git mv [<span class="built_in">source</span>] [destination]</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="http://git-scm.com/docs/git-mv" target="_blank" rel="noopener">Git docs：git-mv manpage</a> </li></ul><h3 id="提交到本地仓库-–-git-commit"><a href="#提交到本地仓库-–-git-commit" class="headerlink" title="提交到本地仓库 – git commit"></a>提交到本地仓库 – git commit</h3><p><strong>提交暂存区到本地仓库：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">"注释"</span></span><br></pre></td></tr></table></figure><p>也可以指定暂存区的文件提交到本地仓库，只要在 commit 后面指定 <code>file</code>。</p><p><strong>跳过暂存区</strong>，直接将工作区自上次 commit 之后的变化，提交到本地仓库：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit -a</span><br></pre></td></tr></table></figure><p><strong>使用一次新的 commit，替代上一次提交：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit --amend -m <span class="string">"注释"</span></span><br><span class="line"><span class="comment"># 如果代码没有任何新变化，则用来改写上一次 commit 的提交信息</span></span><br></pre></td></tr></table></figure><p><strong>重做上一次 commit，并包括指定文件的新变化：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="http://git-scm.com/docs/git-commit" target="_blank" rel="noopener">Git docs：git-commit manpage</a></li></ul><h3 id="提交到本地仓库-–-git-log"><a href="#提交到本地仓库-–-git-log" class="headerlink" title="提交到本地仓库 – git log"></a>提交到本地仓库 – git log</h3><p><strong>列出当前分支的版本历史：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p><strong>仅列出包含指定文件修改的 commit：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -p [file]</span><br></pre></td></tr></table></figure><p><strong>限制 log 的显示数量：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> -[<span class="built_in">limit</span>]</span><br></pre></td></tr></table></figure><p><strong>列出所有提交，每行显示一条 commit（仅显示提交的 hash 和 message）：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline</span><br></pre></td></tr></table></figure><p><strong>按提交者名字搜索并显示 commit：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --author=<span class="string">"[pattern]"</span></span><br></pre></td></tr></table></figure><p><strong>按指定内容搜索并显示 commit：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --grep=<span class="string">"[pattern]"</span></span><br></pre></td></tr></table></figure><p><strong>显示图形化的 branch 信息：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --graph</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="http://git-scm.com/docs/git-log" target="_blank" rel="noopener">Git docs：git-log manpage</a></li></ul><h3 id="提交到本地仓库-–-git-reflog"><a href="#提交到本地仓库-–-git-reflog" class="headerlink" title="提交到本地仓库 – git reflog"></a>提交到本地仓库 – git reflog</h3><p><strong>列出本地仓库的所有 commit：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br></pre></td></tr></table></figure><h3 id="提交到本地仓库-–-git-blame"><a href="#提交到本地仓库-–-git-blame" class="headerlink" title="提交到本地仓库 – git blame"></a>提交到本地仓库 – git blame</h3><p><strong>列出指定文件是什么人在什么时间修改过：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git blame [file]</span><br></pre></td></tr></table></figure><p><strong>也可以具体查文档内部某一部分是谁修改：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git blame [filename] -L &lt;start&gt;,&lt;end&gt;</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><a href="https://git-scm.com/docs/git-blame" target="_blank" rel="noopener">Git docs：git-blame manpage</a></li></ul><h3 id="远程仓库-–-拉取到本地"><a href="#远程仓库-–-拉取到本地" class="headerlink" title="远程仓库 – 拉取到本地"></a>远程仓库 – 拉取到本地</h3><p><strong>拉取远程仓库的所有变动到本地，但不合并：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git fetch [remote]</span><br></pre></td></tr></table></figure><p><strong>拉取远程仓库特定分支的更新到本地，不合并：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git fetch [remote] [branch]</span><br></pre></td></tr></table></figure><p><strong>拉取远程仓库的所有变动到本地，之后自动与 HEAD 版本合并：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br></pre></td></tr></table></figure><p><strong>拉取远程仓库的所有变动到本地，并以 <code>rebase</code> 模式并入本地仓库：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git pull --rebase [remote]</span><br></pre></td></tr></table></figure><p><strong>列出当前配置的所有远程端：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure><ul><li>如果远程仓库不止一个，那么就会全部列出，比如和<strong>多个协作者</strong>合作的，这样可以非常方便地拉取其他用户的贡献，还拥有向他们推送的权限。</li></ul><p><strong>显示某个远程端的信息：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote show [remote]</span><br></pre></td></tr></table></figure><p><strong>增加一个新的远程仓库，并指定简写：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote add [shortname] [url]</span><br></pre></td></tr></table></figure><h3 id="远程仓库-–-推送到远程"><a href="#远程仓库-–-推送到远程" class="headerlink" title="远程仓库 – 推送到远程"></a>远程仓库 – 推送到远程</h3><p><strong>上传本地指定分支到远程仓库：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push [remote] [branch]</span><br><span class="line"></span><br><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><p>注意：只有当有推送到该远程仓库的权限，及之前没有人推送过时，该命令才有效。如果有他人先推送到上游，那么，此时的推送命令就会被拒绝，必须先抓取他们的工作并将其合并到本地仓库，才能推送。</p><p>参考：</p><ul><li><a href="http://git-scm.com/book/en/v2/Git-Branching-Remote-Branches" target="_blank" rel="noopener">Git book：remote branches</a></li></ul><h3 id="分支-–-git-branch"><a href="#分支-–-git-branch" class="headerlink" title="分支 – git branch"></a>分支 – git branch</h3><p><strong>列出本地仓库的所有分支：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br></pre></td></tr></table></figure><p><strong>列出所有远程分支：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -r</span><br></pre></td></tr></table></figure><p><strong>列出所有本地分支和远程分支：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -a</span><br></pre></td></tr></table></figure><p><strong>新建一个分支，但依然停留在当前分支：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch [branch-name]</span><br></pre></td></tr></table></figure><p><strong>新建一个分支，并切换到该分支：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b [brach]</span><br></pre></td></tr></table></figure><p><strong>新建一个分支，指向指定 commit：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch [branch] [commit]</span><br></pre></td></tr></table></figure><p><strong>新建一个分支，与指定的远程分支建立追踪关系：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch --track [branch] [remote-branch]</span><br></pre></td></tr></table></figure><p><strong>建立追踪关系，在现有分支与指定的远程分支之间：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch --<span class="built_in">set</span>-upstream [branch] [remote-branch]</span><br></pre></td></tr></table></figure><p><strong>切换到指定分支，并更新工作区：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout [branch-name]</span><br></pre></td></tr></table></figure><p><strong>切换到上一个分支：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -</span><br></pre></td></tr></table></figure><p><strong>合并指定分支到当前分支：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git merge [branch]</span><br></pre></td></tr></table></figure><p><strong>选择一个 commit，合并进当前分支：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick [commit]</span><br></pre></td></tr></table></figure><p><strong>删除分支：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git branch -d [branch-name]</span><br></pre></td></tr></table></figure><p>若该分支的修改尚未合并，那么用 <code>-D</code> 参数来强制删除分支，注意，该操作会丢失未合并的修改。</p><p><strong>删除远程分支：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br></pre></td></tr></table></figure><h3 id="分支-–-git-rebase"><a href="#分支-–-git-rebase" class="headerlink" title="分支 – git rebase"></a>分支 – git rebase</h3><p><strong>基于 base 对当前分支进行 rebase。</strong>base 可以是 commit、分支名称、tag 或者相对于 HEAD 的 commit。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git rebase [base]</span><br></pre></td></tr></table></figure><p>参考：</p><ul><li><p><a href="http://git-scm.com/docs/git-rebase" target="_blank" rel="noopener">Git docs：git-rebase manpage</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1y4411Y7V2" target="_blank" rel="noopener">B站视频：git-rebase 图解</a></p></li></ul><h3 id="回滚-–-git-revert"><a href="#回滚-–-git-revert" class="headerlink" title="回滚 – git revert"></a>回滚 – git revert</h3><p><strong>新建一个 commit，用来撤销指定 commit，并且应用到当前分支：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git revert [commit]</span><br><span class="line"><span class="comment"># revert a specific commit</span></span><br><span class="line"></span><br><span class="line">$ git revert HEAD </span><br><span class="line"><span class="comment"># revert the last commit</span></span><br></pre></td></tr></table></figure><h3 id="回滚-–-git-checkout"><a href="#回滚-–-git-checkout" class="headerlink" title="回滚 – git checkout"></a>回滚 – git checkout</h3><p><strong>恢复暂存区的指定文件到工作区：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout [file]</span><br></pre></td></tr></table></figure><p><strong>恢复某个 commit 的指定文件到暂存区和工作区：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout [commit] [file]</span><br></pre></td></tr></table></figure><p><strong>恢复暂存区的所有文件到工作区：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout .</span><br></pre></td></tr></table></figure><h3 id="回滚-–-git-reset"><a href="#回滚-–-git-reset" class="headerlink" title="回滚 – git reset"></a>回滚 – git reset</h3><p><strong>重置暂存区的指定文件</strong>，与上一次 commit 保持一致，但<strong>工作区不变</strong>，即撤销这个文件上次的 <code>git add</code>：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset [file]</span><br><span class="line"></span><br><span class="line">$ git reset HEAD</span><br><span class="line"><span class="comment"># 移除暂存区的所有文件</span></span><br></pre></td></tr></table></figure><p><strong>重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset [commit]</span><br></pre></td></tr></table></figure><p><strong>重置暂存区与工作区，与上一次 commit 保持一致：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset --hard</span><br></pre></td></tr></table></figure><p><strong>重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset --hard [commit]</span><br></pre></td></tr></table></figure><p><strong>重置当前HEAD为指定 commit，但保持暂存区和工作区不变：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset --keep [commit]</span><br></pre></td></tr></table></figure><p><strong>暂时将未提交的变化移除，稍后再移入：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure><h3 id="回滚-–-具体场景"><a href="#回滚-–-具体场景" class="headerlink" title="回滚 – 具体场景"></a>回滚 – 具体场景</h3><p class="text-danger">场景1. 已经提交内容到本地仓库</p><p>如何回滚？</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line"><span class="comment"># 返回到上一个版本</span></span><br></pre></td></tr></table></figure><p class="text-danger">场景2. 修改了还未提交到暂存区</p><p>怎么撤销？</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout --readme.txt</span><br><span class="line"><span class="comment"># 丢弃 readme 文件在工作区的修改</span></span><br></pre></td></tr></table></figure><ul><li><p>补充：</p><p>一种是<strong>该文件自修改后还没有放到暂存区</strong>，那么，现在撤销修改，就是<strong>回到和版本库一模一样的状态</strong>；</p><p>另一种是该文件<strong>添加到暂存区后</strong>，<strong>又做了修改</strong>，那么现在撤销修改，就是<strong>回到添加到暂存区后的状态</strong>；</p></li></ul><p class="text-danger">场景3. 提交到暂存区，但还未提交到本地仓库</p><p>怎么办？</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD readme.txt</span><br></pre></td></tr></table></figure><ul><li><p><strong>把暂存区的修改撤销（unstage），重新放回工作区。</strong></p><p>所以， <code>git reset</code>既可以回退版本，也可以把暂存区的修改回退到工作区。</p><p>之后，丢弃工作区的修改即可。</p></li></ul><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p><strong>列出所有标签：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag</span><br></pre></td></tr></table></figure><p><strong>给当前版本打标签：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag [tag-name]</span><br></pre></td></tr></table></figure><p><strong>给指定 commit 打标签：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag [tag] [commit]</span><br></pre></td></tr></table></figure><p> <strong>删除本地标签：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git tag -d [tag]</span><br></pre></td></tr></table></figure><p><strong>删除远程标签：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push origin :refs/tags/[tagName]</span><br></pre></td></tr></table></figure><p><strong>提交指定标签：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push [remote] [tag]</span><br></pre></td></tr></table></figure><p><strong>提交所有标签：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git push [remote] --tags</span><br></pre></td></tr></table></figure><p><strong>新建一个分支，指向某个标签：</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure><h2 id="Git-的-GUI-工具"><a href="#Git-的-GUI-工具" class="headerlink" title="Git 的 GUI 工具"></a>Git 的 GUI 工具</h2><h3 id="SourceTree"><a href="#SourceTree" class="headerlink" title="SourceTree"></a>SourceTree</h3><p><a href="https://www.sourcetreeapp.com/" target="_blank" rel="noopener">SourceTree 官网</a></p><h3 id="IntelliJ-IDEA-中的-Git"><a href="#IntelliJ-IDEA-中的-Git" class="headerlink" title="IntelliJ IDEA 中的 Git"></a>IntelliJ IDEA 中的 Git</h3><p><a href="https://www.jetbrains.com/help/idea/using-git-integration.html" target="_blank" rel="noopener">IntelliJ IDEA 官方文档</a></p><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ol><li><p>Pro Git book by  Scott Chacon and Ben Straub. The book is available online for free at <a href="http://git-scm.com/book/en/v2" target="_blank" rel="noopener">git-scm.com/book</a>.</p></li><li><p><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">常用 Git 命令清单：阮一峰的网络日志</a>.</p></li><li><p><a href="https://github.com/hbons/git-cheat-sheet" target="_blank" rel="noopener">Git Cheat Sheet</a>: made by Hylke Bons.</p></li><li><p><a href="https://github.com/flyhigher139/Git-Cheat-Sheet" target="_blank" rel="noopener">Git Cheat Sheet 中文版</a>: translated by Gevin.</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣509.斐波那契数列</title>
      <link href="/2021/05/02/lc509/"/>
      <url>/2021/05/02/lc509/</url>
      
        <content type="html"><![CDATA[<p class="text-danger">© 本文版权归作者Link 所有，转载请注明出处。</p><p class="text-success">LeetCode | 509. 斐波那契数列 Fibonacci number【easy】(Java代码)</p><h2 id="暴力递归法"><a href="#暴力递归法" class="headerlink" title="暴力递归法"></a>暴力递归法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Recursion</span></span><br><span class="line"><span class="comment">Time Complexity: O(2^n);</span></span><br><span class="line"><span class="comment">Space Complexity: O(n);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="记忆化递归法"><a href="#记忆化递归法" class="headerlink" title="记忆化递归法"></a>记忆化递归法</h2><h3 id="数组做-Memo-ArrayList"><a href="#数组做-Memo-ArrayList" class="headerlink" title="数组做 Memo - ArrayList"></a>数组做 Memo - ArrayList</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Recursion + Memoization (array)-use java.util.ArrayList</span></span><br><span class="line"><span class="comment">Time Complexity: less than O(2^n);</span></span><br><span class="line"><span class="comment">Space Complexity: O(n);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> ArrayList&lt;&gt;(n+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// prepare: put -1 into empty arr</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt;n+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            arr.add(i, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> fibRecursion(arr, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibRecursion</span><span class="params">(ArrayList&lt;Integer&gt; arr, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(arr.get(n) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> arr.get(n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>);</span><br><span class="line">        arr.set(n, sum);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组做-Memo-Arrays"><a href="#数组做-Memo-Arrays" class="headerlink" title="数组做 Memo - Arrays"></a>数组做 Memo - Arrays</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Recursion + Memoization (array)-use java.util.Arrays</span></span><br><span class="line"><span class="comment">Time Complexity: less than O(2^n);</span></span><br><span class="line"><span class="comment">Space Complexity: O(n);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] memo = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// prepare: put -1 into this empty array</span></span><br><span class="line">        Arrays.fill(memo, -<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> fibRecursion(memo, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fibRecursion</span><span class="params">(<span class="keyword">int</span>[] memo, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(memo[n] != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> memo[n];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>);</span><br><span class="line">        memo[n] = sum;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希表做-Memo"><a href="#哈希表做-Memo" class="headerlink" title="哈希表做 Memo"></a>哈希表做 Memo</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Recursion + Memoization (hashtable)</span></span><br><span class="line"><span class="comment">Time Complexity: less than O(2^n);</span></span><br><span class="line"><span class="comment">Space Complexity: O(n);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(n))&#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> sum = fib(n-<span class="number">1</span>) + fib(n-<span class="number">2</span>);</span><br><span class="line">        map.put(n, sum);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态规划法"><a href="#动态规划法" class="headerlink" title="动态规划法"></a>动态规划法</h2><h3 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Dynamic Programing - basic</span></span><br><span class="line"><span class="comment">Time Complexity: O(n);</span></span><br><span class="line"><span class="comment">Space Complexity: O(n);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] f= <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    f[<span class="number">1</span>]= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        f[i] =f[i-<span class="number">1</span>]+f[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DP-优化"><a href="#DP-优化" class="headerlink" title="DP 优化"></a>DP 优化</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Dynamic Programing - optimize</span></span><br><span class="line"><span class="comment">Time Complexity: O(n);</span></span><br><span class="line"><span class="comment">Space Complexity: O(1);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pre = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> next = pre + cur;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h2><ol><li><p><a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">【力扣直通车】509. 斐波那契数列</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1Kv411j7qU" target="_blank" rel="noopener">【BiliBili视频】LeetCode 509. Fibonacci Number | 思路梳理</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms &amp; data structure；Java； </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>something about SQL</title>
      <link href="/2021/04/11/something-about-SQL/"/>
      <url>/2021/04/11/something-about-SQL/</url>
      
        <content type="html"><![CDATA[<p class="text-danger">© 本文版权归作者Link 所有，转载请注明出处。</p><h2 id="SQL运行原理"><a href="#SQL运行原理" class="headerlink" title="SQL运行原理"></a>SQL运行原理</h2><ol><li>准备表格<ol><li>复制源数据进行连接，筛选；<ol><li>FROM</li><li>JOIN：连接表格；</li><li>WHERE：将数据按以下条件筛选；</li></ol></li><li>如果需要聚合运算，则基于连接、筛选好的数据，创建“数据透视表”；<ol><li>GROUP BY：按以下字段和条件<strong>分组</strong>；<ol><li>SQL 中的 GROUP BY 是对数据进行去重合并，为后续聚合运算做准备。要注意：具体的聚合运算还是由聚合函数进行的；</li></ol></li><li>HAVING：在分组后的数据中找到满足以下条件的数据；<ol><li>数据分组后，对<strong>作为分组依据的非聚合字段</strong>和<strong>分组后聚合运算的结果</strong>进行筛选。</li></ol></li></ol></li></ol></li><li>查询字段<ol><li>对准备好的表格进行排序和行数限制；<ol><li>ORDER BY：<ol><li>按照字段的顺序对表格的行进行排序，SQL中默认升序，降序要在字段后加 DESC（descent）；</li></ol></li><li>LIMIT：留下指定行数或指定位置的数据；<ol><li>LIMIT n，则返回前 n 行，如 LIMIT 10，返回前 10 行；</li><li>LIMIT x, y，则从第 x 行后返回 y 行，如 LIMIT 10, 2，则会返回第11和12行；</li><li>常用来取固定名次的数据，或进行数据的初步查看</li></ol></li></ol></li><li>查询表格中的字段，并基于已有的字段进行计算；<ol><li>SELECT</li></ol></li></ol></li><li>处理函数<ol><li>DISTINCT：去重，去重计数 COUNT(DISTINCT xx)；<ol><li>SQL 中的 DISTINCT 实际是删除操作，把重复的都删去；</li></ol></li><li>LIKE、%通配符、_占位符模糊查询；</li><li>聚合函数；</li><li>CASE WHEN 条件判断函数；</li><li>COALESCE()空值处理函数</li><li>OVER()窗口函数； </li></ol></li></ol><h2 id="SQL代码规范"><a href="#SQL代码规范" class="headerlink" title="SQL代码规范"></a>SQL代码规范</h2><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ol><li><p>单行注释：–</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col_name <span class="comment">-- 这是一条注释</span></span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>多行注释：/* 注释内容 */</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*SELECT col_name </span></span><br><span class="line"><span class="comment">FROM table_name;*/</span></span><br><span class="line"><span class="keyword">SELECT</span> col_2 </span><br><span class="line"><span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure></li></ol><h3 id="其他规范"><a href="#其他规范" class="headerlink" title="其他规范"></a>其他规范</h3><ol><li>SQL语句不区分大小写，因此 SELECT 与 select 甚至是 SeLect 的效果是相同的，但是要对命令和变量进行区分，所以默认命令需要大写，其他内容如变量等则需要小写</li><li>表和变量名中不要出现空格，可使用下划线_替代</li><li>查询语句中，使用单一空格隔开命令和变量</li><li>逗号写在字段前面</li><li>注意换行</li><li>核心语句的内容能写在一行尽量写在一行</li><li>WHERE 语句过长时，每个都要换行</li><li>注意缩进：CASE WHEN 同一级别的条件，子查询，别名尽量统一缩进，代码结束处加;</li></ol><h2 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h2><p>聚合函数：有时候我们只是需要获取数据的汇总信息，比如行数、平均值，并不需要把所有数据都检索出来。为此，SQL提供了专门的函数，这也是SQL最强大功能之一。</p><p>SQL的聚合函数如下：</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>AVG()</td><td>返回某列的均值</td></tr><tr><td>COUNT()</td><td>返回某列的行数</td></tr><tr><td>MAX()</td><td>返回某列的最大值</td></tr><tr><td>MIN()</td><td>返回某列的最小值</td></tr><tr><td>SUM()</td><td>返回某列的和</td></tr></tbody></table><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>重要的是逻辑</p><ol><li>子查询就是将一个查询（子查询）的结果，作为另一个查询（主查询）的<strong>数据来源</strong>或<strong>判断条件</strong>的查询。</li><li>常见的子查询有 WHERE 子查询，FROM 子查询，SELECT 子查询，EXISTS 子查询，子查询要用小括号 ()；<ul><li>【好文详解】<a href="https://www.cnblogs.com/fzxey/p/10896244.html" target="_blank" rel="noopener">SQL中的子查询</a></li></ul></li><li>如果感觉一次查询无法完成，就使用子查询，然后再逐步优化。</li></ol><h2 id="表连接"><a href="#表连接" class="headerlink" title="表连接"></a>表连接</h2><p>脑海里一定要有两个具象化的表格</p><p>JOIN</p><ul><li>【好文详解】<a href="https://www.cnblogs.com/reaptomorrow-flydream/p/8145610.html" target="_blank" rel="noopener">SQL的各种连接JOIN详解</a></li></ul><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><h3 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h3><p>插入新记录</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> &lt;表名&gt;(字段<span class="number">1</span>, 字段<span class="number">2</span>, ...) <span class="keyword">VALUES</span>(值<span class="number">1</span>, 值<span class="number">2</span>, ...);</span><br><span class="line"><span class="comment">-- 添加一条新记录</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> world(<span class="keyword">name</span>, continent, population) <span class="keyword">VALUES</span>(<span class="string">'New York'</span>, <span class="string">'Asia'</span>, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">-- 查询看看</span></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> world;</span><br></pre></td></tr></table></figure><p>可以一次性添加多条记录，只需要在 VALUE 子句中指定多个记录值，每个记录值是由 (…) 包含的一组值。</p><ul><li><a href="https://www.liaoxuefeng.com/wiki/1177760294764384/1179611138358240" target="_blank" rel="noopener">廖雪峰：SQL教程-INSERT</a></li></ul><h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><p>更新已有记录</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> &lt;表名&gt; <span class="keyword">SET</span> 字段<span class="number">1</span>=值<span class="number">1</span>, 字段<span class="number">2</span>=值<span class="number">2</span>, ... <span class="keyword">WHERE</span> ...;</span><br><span class="line"><span class="comment">-- 更新 id=1 的记录</span></span><br><span class="line"><span class="keyword">UPDATE</span> world <span class="keyword">SET</span> <span class="keyword">name</span> = <span class="string">'New York'</span>, continent = <span class="string">'Asia'</span>, population = <span class="number">1000</span> <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 查询看看</span></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> world </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>可以一次性更新多条记录，通过 WHERE 条件。</p><p>更新字段可以用表达式，比如亚洲的国家人口都加一百万（6个0）。</p><p>注意：UPDATE 语句中如果没有 WHERE 条件，那么，整个表的所有记录都会更新。</p><ul><li><a href="https://www.liaoxuefeng.com/wiki/1177760294764384/1179611161425120" target="_blank" rel="noopener">廖雪峰：SQL教程-UPDATE</a></li></ul><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><p>删除已有记录</p><p>语法：</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> &lt;表名&gt; <span class="keyword">WHERE</span> ...;</span><br><span class="line"><span class="comment">-- 删除 id=1 的记录</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> world <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br><span class="line"><span class="comment">-- 查询看看</span></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> world </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>可以一次性删除多条记录，通过 WHERE 条件。</p><p>注意：DELETE 语句中如果没有 WHERE 条件，那么，整个表的所有记录都会被删除。</p><ul><li><a href="https://www.liaoxuefeng.com/wiki/1177760294764384/1179611171910432" target="_blank" rel="noopener">廖雪峰：SQL教程-DELETE</a></li></ul><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ol><li><a href="https://mubu.com/doc/4BHMMbbvIMb" target="_blank" rel="noopener">戴师兄3天SQL入门教程刷题链接</a></li><li><a href="https://mubu.com/doc/uf3vg8s5ar" target="_blank" rel="noopener">元旦3天SQL特训营</a></li><li><a href="https://mubu.com/doc/eGQ0OKyH2w" target="_blank" rel="noopener">SQL学习总结</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> SQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>力扣4.寻找两个正序数组的中位数</title>
      <link href="/2021/04/05/lc4/"/>
      <url>/2021/04/05/lc4/</url>
      
        <content type="html"><![CDATA[<p class="text-danger">© 本文版权归作者Link 所有，转载请注明出处。</p><p class="text-success">LeetCode | 4. 寻找两个正序数组的中位数 Median of Two Sorted Arrays 【hard】(Java代码)</p><h2 id="二分查找法"><a href="#二分查找法" class="headerlink" title="二分查找法"></a>二分查找法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">Binary Search</span></span><br><span class="line"><span class="comment">    n is the size of numsA;</span></span><br><span class="line"><span class="comment">    m is the size of numsB;</span></span><br><span class="line"><span class="comment">    Time Complexity: O(log(min(n, m)));</span></span><br><span class="line"><span class="comment">    Space Complexity: O(1);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] numsA, <span class="keyword">int</span>[] numsB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = numsA.length;</span><br><span class="line">        <span class="keyword">int</span> m = numsB.length;</span><br><span class="line">        <span class="keyword">int</span> mn = n + m;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n &gt; m)&#123;</span><br><span class="line">            <span class="keyword">return</span> findMedianSortedArrays(numsB, numsA);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ((<span class="keyword">double</span>)numsB[(m-<span class="number">1</span>)/<span class="number">2</span>] + (<span class="keyword">double</span>)numsB[m/<span class="number">2</span>])/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> j = n;</span><br><span class="line">        <span class="keyword">int</span> cutA = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cutB = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">            cutA = (i + j) / <span class="number">2</span>;</span><br><span class="line">            cutB = (mn + <span class="number">1</span>) / <span class="number">2</span> - cutA;</span><br><span class="line">            <span class="keyword">int</span> al = (cutA == <span class="number">0</span>)? Integer.MIN_VALUE: numsA[cutA-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> ar = (cutA == n)? Integer.MAX_VALUE: numsA[cutA];</span><br><span class="line">            <span class="keyword">int</span> bl = (cutB == <span class="number">0</span>)? Integer.MIN_VALUE: numsB[cutB-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> br = (cutB == m)? Integer.MAX_VALUE: numsB[cutB];</span><br><span class="line">            <span class="keyword">if</span>(al&gt;br)&#123;</span><br><span class="line">                j = cutA - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bl&gt;ar)&#123;</span><br><span class="line">                i = cutA + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>((mn &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> (Math.max(al, bl) + Math.min(ar, br))/<span class="number">2.0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> Math.max(al, bl);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">iterate</span></span><br><span class="line"><span class="comment">  n is the size of numsA;</span></span><br><span class="line"><span class="comment">  m is the size of numsB;</span></span><br><span class="line"><span class="comment">  Time Complexity: O(n+m));</span></span><br><span class="line"><span class="comment">  Space Complexity: O(1);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="keyword">int</span>[] numsA, <span class="keyword">int</span>[] numsB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = numsA.length;</span><br><span class="line">        <span class="keyword">int</span> m = numsB.length;</span><br><span class="line">        <span class="keyword">int</span> mn = n + m;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// l: the element on the neutrality line left side,</span></span><br><span class="line">        <span class="comment">// r: the element on the neutrality line right side;</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// aP：the pointer that iterates numsA,</span></span><br><span class="line">        <span class="comment">// bP：the pointer that iterates numsB;</span></span><br><span class="line">        <span class="keyword">int</span> aP = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bP = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;= mn/<span class="number">2</span> ; i++)&#123;</span><br><span class="line">            l = r;</span><br><span class="line">            <span class="keyword">if</span>(aP&lt;n &amp;&amp; (bP &gt;= m || numsA[aP] &lt; numsB[bP]))&#123;</span><br><span class="line">                r = numsA[aP++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r = numsB[bP++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((mn &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (l+r)/<span class="number">2.0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a>传送门</h2><ol><li><p><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener">【做题直通车】leetcode 4：寻找两个正序数组的中位数</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1ti4y1N7iP" target="_blank" rel="noopener">【BiliBili视频】leetcode 4 | 思路梳理</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithms &amp; data structure; Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git设置ssh密钥</title>
      <link href="/2020/06/22/setting-ssh-key/"/>
      <url>/2020/06/22/setting-ssh-key/</url>
      
        <content type="html"><![CDATA[<p class="text-danger">© 本文版权归作者Link 所有，若转载请注明出处，谢谢！</p><hr><p>git 支持 https 和 git 两种传输协议：</p><ul><li>https 协议，每次pull, push都会提示要输入密码；</li><li>git 协议，然后使用 ssh 密钥，这样免去每次都输密码的麻烦。</li></ul><p>初次使用 git 的用户要使用 git 协议大概需要三个步骤：</p><ol><li>生成密钥对</li><li>设置远程仓库（本文以github为例）上的公钥</li><li>把git的 remote url 修改为git协议</li></ol><h2 id="生成密钥对"><a href="#生成密钥对" class="headerlink" title="生成密钥对"></a>生成密钥对</h2><p>大多数 Git 服务器都会选择使用 SSH 公钥来进行授权。系统中的每个用户都必须提供一个公钥用于授权，没有的话就要生成一个。生成公钥的过程在所有操作系统上都差不多。</p><p>首先你要确认一下本机是否已经有一个公钥。</p><ul><li>SSH 公钥默认储存在账户的主目录下的 ~/.ssh 目录。进去看看：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/.ssh</span><br><span class="line">$ ls <span class="comment"># 列出当前目录下的所有文件和目录</span></span><br><span class="line">id_rsa   known_hosts   id_rsa.pub</span><br></pre></td></tr></table></figure><p>看一下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>(或者是<code>id_dsa</code>和<code>id_dsa.pub</code>之类成对的文件)，有 .pub 后缀的文件就是公钥，另一个文件则是密钥。</p><ul><li>假如没有这些文件，甚至连 .ssh 目录都没有，可以用 <code>ssh-keygen</code>来创建新的ssh key：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"your_email@youremail.com"</span></span><br><span class="line"></span><br><span class="line">Creates a new ssh key using the provided email </span><br><span class="line"><span class="comment"># Generating public/private rsa key pair.</span></span><br><span class="line"></span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/home/you/.ssh/id_rsa):</span><br></pre></td></tr></table></figure><p>按Enter。</p><p>然后，会提示你输入密码，如下：</p><p>(输一个，会安全一点，但是之后每次pull, push都会要求输入这个密码；若不输入，直接回车，就少了一点安全，但是省去了麻烦)</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Enter same passphrase again: [Type passphrase again]</span><br></pre></td></tr></table></figure><p>完成之后，大概是这样显示：</p><figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Your</span> <span class="selector-tag">public</span> <span class="selector-tag">key</span> <span class="selector-tag">has</span> <span class="selector-tag">been</span> <span class="selector-tag">saved</span> <span class="selector-tag">in</span> /<span class="selector-tag">home</span>/<span class="selector-tag">you</span>/<span class="selector-class">.ssh</span>/<span class="selector-tag">id_rsa</span><span class="selector-class">.pub</span>.</span><br><span class="line"><span class="selector-tag">The</span> <span class="selector-tag">key</span> <span class="selector-tag">fingerprint</span> <span class="selector-tag">is</span>: # <span class="selector-tag">01</span><span class="selector-pseudo">:0f</span><span class="selector-pseudo">:f4</span><span class="selector-pseudo">:3b</span><span class="selector-pseudo">:ca</span><span class="selector-pseudo">:85</span><span class="selector-pseudo">:d6</span><span class="selector-pseudo">:17</span><span class="selector-pseudo">:a1</span><span class="selector-pseudo">:7d</span><span class="selector-pseudo">:f0</span><span class="selector-pseudo">:68</span><span class="selector-pseudo">:9d</span><span class="selector-pseudo">:f0</span><span class="selector-pseudo">:a2</span><span class="selector-pseudo">:db</span> <span class="selector-tag">your_email</span>@<span class="selector-tag">youremail</span><span class="selector-class">.com</span></span><br></pre></td></tr></table></figure><p>到此为止，本地的密钥对就生成了。</p><h2 id="添加公钥到你的远程仓库（github）"><a href="#添加公钥到你的远程仓库（github）" class="headerlink" title="添加公钥到你的远程仓库（github）"></a>添加公钥到你的远程仓库（github）</h2><ol><li>查看刚刚生成的公钥：</li></ol><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cat ~/.ssh/id_rsa.pub</span><br><span class="line"><span class="comment"># 显示文件中的内容</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>登陆GitHub帐户, user settings <code>-&gt;</code> SSH and GPG keys <code>-&gt;</code> New SSH key</p></li><li><p>然后复制上面的公钥内容，粘贴进 Key 文本域内。 title 域，自己随便起个名字。</p></li><li><p>Add key。</p></li></ol><p>验证下这个key是不是正常工作：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br><span class="line">Attempts to ssh to github</span><br></pre></td></tr></table></figure><p>如果，看到：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hi xxx! You<span class="string">'ve successfully authenticated, but GitHub does not # provide shell access.</span></span><br></pre></td></tr></table></figure><p>说明设置成功了。</p><h2 id="修改git的remote-url"><a href="#修改git的remote-url" class="headerlink" title="修改git的remote url"></a>修改git的remote url</h2><p>使用命令 <code>git remote -v</code>查看你当前的 remote url：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin https://github.com/someaccount/someproject.git (fetch)</span><br><span class="line">origin https://github.com/someaccount/someproject.git (push)</span><br></pre></td></tr></table></figure><p>如果是以上的结果那么说明此项目是使用https协议进行访问的（如果地址是git开头则表示是git协议）</p><ul><li>你可以登陆GitHub，在上面可以看到ssh协议相应的url，复制此ssh链接，然后使用命令<code>git remote set-url</code>来调整url：</li></ul><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote <span class="built_in">set</span>-url origin git@github.com:someaccount/someproject.git</span><br></pre></td></tr></table></figure><p>然后你可以再用命令 <code>git remote -v</code> 查看一下，url是否已经变成了ssh地址。</p><p>the end.</p><h2 id="更多链接"><a href="#更多链接" class="headerlink" title="更多链接"></a>更多链接</h2><ol><li><p><a href="https://blog.csdn.net/xiaomengzi_16/article/details/98847298" target="_blank" rel="noopener">git配置公匙时不必输入密码</a> </p><p>csdn的一篇文章，详细风趣地讲解了一个我曾犯过的错误。</p></li><li><p><a href="https://www.cnblogs.com/superGG1990/p/6844952.html" target="_blank" rel="noopener">git如何使用ssh密钥</a> </p><p>博客园 <a href="https://home.cnblogs.com/u/superGG1990/" target="_blank" rel="noopener">superGG1990</a> 的一篇文章，是一个很好的 walkthrough，我的这篇文章就是基于此文写的一个 summary。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> wiki </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图床的使用</title>
      <link href="/2020/06/18/picbed/"/>
      <url>/2020/06/18/picbed/</url>
      
        <content type="html"><![CDATA[<p class="text-danger">© 本文版权归作者Link 所有，若转载请注明出处，谢谢！</p><p>在Typora中利用PicGo自动上传图片到SM.MS图床。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol><li><p>install <code>Typora</code>，<code>PicGo</code>，<code>Git</code>，<code>Node.js</code></p><span class="label label-info">Typora</span><span class="label label-primary">PicGo</span><span class="label label-warning">Git</span><span class="label label-danger">Node.js</span></li><li><p>register <code>sm.ms</code></p></li><li><p>PicGo 安装 sm.ms 插件</p><ul><li><p>app 中<code>插件设置</code>搜索 <code>smms-user</code>，安装即可</p></li><li><p>picgo 的官方文档写得易懂详细，推荐阅读（<a href="https://picgo.github.io/PicGo-Doc/zh/guide" target="_blank" rel="noopener">PicGo-Doc</a>）。</p></li></ul></li></ol><h2 id="PicGo-amp-SM-MS"><a href="#PicGo-amp-SM-MS" class="headerlink" title="PicGo &amp; SM.MS"></a>PicGo &amp; SM.MS</h2><p>目的是把图床（SM.MS）的 API Access 给 PicGo。</p><ul><li><p>SM.MS中：</p><p>​    –&gt;<code>dashboard</code></p><p>​    –&gt;<code>API Token</code> </p><p>​    click <code>Generate Secret Token</code></p><p>​    copy <code>Secret Token</code></p></li><li><p>PicGo中：</p><p>​    –&gt;<code>图床设置</code></p><p>​    –&gt;<code>SM.MS - 登录用户</code></p><p>​    将 <code>Secret Token</code> 输入 <code>Auth</code>框内</p></li></ul><h2 id="PicGo-amp-Typora"><a href="#PicGo-amp-Typora" class="headerlink" title="PicGo &amp; Typora"></a>PicGo &amp; Typora</h2><p>目的是实现Typora中图片自动地通过 PicGo 上传到图床（SM.MS）。</p><ul><li><p>Typora 中：</p><p>​    –&gt;<code>文件</code> –&gt;<code>偏好设置</code> –&gt;<code>图像</code></p><p>​    图像中各种设置的说明易懂，按需勾选即可。</p><p>   click <code>验证图片上传选项</code></p><p>​    会弹出下图：（现在可能不会成功上传，但现在不要紧）</p></li></ul><img src="https://i.loli.net/2020/06/19/Gc93a52B6XbDxPL.png" class="lazy" data-srcset="https://i.loli.net/2020/06/19/Gc93a52B6XbDxPL.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" alt="111" style="zoom: 67%;" /><p>​        copy 端口号。</p><ul><li><p>PicGo 中：</p><p>​    –&gt;<code>PicGo 设置</code> –&gt;<code>设置 Server</code></p><p>​    输入刚刚 copy 的端口号。</p></li></ul><p>这时 Typora 中进行验证图片上传，就会成功，说明现在Typora中图片可以自动地通过 PicGo 上传到图床（SM.MS）了！</p><p>可以拖一张图片到 Typora 中试验一下。</p><h2 id="PicGo-快捷键"><a href="#PicGo-快捷键" class="headerlink" title="PicGo 快捷键"></a>PicGo 快捷键</h2><ul><li><p>PicGo 支持快捷键<code>command+shift+p</code>（macOS）或者<code>control+shift+p</code>（windows\linux）用以支持快捷上传剪贴板里的图片（第一张）。</p></li><li><p>支持自定义快捷键。</p></li><li><p>每次截图之后，按一下<code>ctrl+shift+p</code>，截图就可以直接上传到sm.ms图床上，并返回链接。</p></li></ul><h2 id="more"><a href="#more" class="headerlink" title="more"></a>more</h2><ol><li><p><a href="https://picgo.github.io/PicGo-Doc/zh/guide" target="_blank" rel="noopener">PicGo-Doc</a></p></li><li><p><a href="https://www.jianshu.com/p/4cd14d4ceb1d" target="_blank" rel="noopener">简书 各种错误排查</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> wiki </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/06/16/hello-world/"/>
      <url>/2020/06/16/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
