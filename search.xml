<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>picbed</title>
      <link href="/2020/06/18/picbed/"/>
      <url>/2020/06/18/picbed/</url>
      
        <content type="html"><![CDATA[<h1 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h1><p>在Typora中利用PicGo自动上传图片到SM.MS图床</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol><li><p>install <code>Typora</code>，<code>PicGo</code>，<code>Git</code>，<code>Node.js</code></p><span class="label label-info">Typora</span><span class="label label-primary">PicGo</span><span class="label label-warning">Git</span><span class="label label-danger">Node.js</span></li><li><p>register <code>sm.ms</code></p></li><li><p>PicGo 安装 sm.ms 插件</p><ul><li><p>app 中<code>插件设置</code>搜索 <code>smms-user</code>，安装即可</p></li><li><p>picgo 的官方文档写得易懂详细，推荐阅读（<a href="https://picgo.github.io/PicGo-Doc/zh/guide" target="_blank" rel="noopener">PicGo-Doc</a>）。</p></li></ul></li></ol><h2 id="PicGo-amp-SM-MS"><a href="#PicGo-amp-SM-MS" class="headerlink" title="PicGo &amp; SM.MS"></a>PicGo &amp; SM.MS</h2><p>目的是把图床（SM.MS）的 API Access 给 PicGo。</p><p>SM.MS中：</p><p>​    –&gt;<code>dashboard</code></p><p>​    –&gt;<code>API Token</code> </p><p>​    –&gt;click <code>Generate Secret Token</code></p><p>​    copy <code>Secret Token</code></p><p>PicGo中：</p><p>​    –&gt;<code>图床设置</code></p><p>​    –&gt;<code>SM.MS-登录用户</code></p><p>​    –&gt;将 <code>Secret Token</code> 输入 <code>Auth</code>框内</p><h2 id="PicGo-amp-Typora"><a href="#PicGo-amp-Typora" class="headerlink" title="PicGo &amp; Typora"></a>PicGo &amp; Typora</h2><p>目的是实现Typora中图片自动地通过 PicGo 上传到图床（SM.MS）。</p><p>Typora 中：</p><p>​    –&gt;<code>文件</code> –&gt;<code>偏好设置</code> –&gt;<code>图像</code></p><p>​    图像中各种设置的说明易懂，按需勾选即可。</p><p>   click <code>验证图片上传选项</code></p><p>​    会弹出下图：</p><ul><li>（可能不会成功上传，但现在不要紧）</li></ul><img src="https://i.loli.net/2020/06/19/Gc93a52B6XbDxPL.png" alt="111" style="zoom: 67%;" /><p>​    copy 端口号。</p><p>PicGo 中：</p><p>​    –&gt;<code>PicGo 设置</code> –&gt;<code>设置 Server</code></p><p>​    输入刚刚 copy 的端口号。</p><p>这时 Typora 中进行验证图片上传就可以成功，说明现在Typora中图片可以自动地通过 PicGo 上传到图床（SM.MS）了！</p><p>可以拖一张图片到 Typora 中试验一下。</p><h2 id="PicGo-快捷键"><a href="#PicGo-快捷键" class="headerlink" title="PicGo 快捷键"></a>PicGo 快捷键</h2><ul><li><p>PicGo 支持快捷键<code>command+shift+p</code>（macOS）或者<code>control+shift+p</code>（windows\linux）用以支持快捷上传剪贴板里的图片（第一张）。</p></li><li><p>支持自定义快捷键。</p></li><li><p>每次截图之后，按一下<code>ctrl+shift+p</code>，截图就可以直接上传到sm.ms图床上，并返回链接。</p></li></ul><h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ol><li><p><a href="https://picgo.github.io/PicGo-Doc/zh/guide" target="_blank" rel="noopener">PicGo-Doc</a></p></li><li><p><a href="https://www.jianshu.com/p/4cd14d4ceb1d" target="_blank" rel="noopener">简书 各种错误排查</a></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Git向导</title>
      <link href="/2020/06/16/git-guide/"/>
      <url>/2020/06/16/git-guide/</url>
      
        <content type="html"><![CDATA[<h3 id="intro-to-Git"><a href="#intro-to-Git" class="headerlink" title="intro to Git"></a>intro to Git</h3><p>What is Git?</p><p><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a>是一个分布式版本控制系统（<a href="https://en.wikipedia.org/wiki/Distributed_version_control" target="_blank" rel="noopener">Distributed Version Control System</a>）</p><ul><li><p>客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。</p></li><li><p>特点：</p><ul><li>直接记录快照，而非差异比较；</li><li>近乎所有操作都是本地执行；</li><li>Git 保证完整性；</li><li>Git 一般只添加数据；</li></ul></li><li><p><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">关系图示</a></p><p>An image from ruanyifeng’s blog is placed here for your convenience:</p></li></ul><p>Git has excellent <a href="http://git-scm.com/documentation" target="_blank" rel="noopener">documentation</a> so we highly encourage those who are interested to read more about what will be summarized in the rest of this guide.</p><hr><h3 id="Local-Repositories-Overview"><a href="#Local-Repositories-Overview" class="headerlink" title="Local Repositories  (Overview)"></a>Local Repositories  (Overview)</h3><h4 id="intro"><a href="#intro" class="headerlink" title="intro"></a>intro</h4><p>三种状态：</p><ul><li><p>Git 有三种状态，你的文件可能处于其中之一：</p><ul><li><code>modified</code>：表示修改了文件，但还没保存到数据库中。</li><li><code>staged</code>：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li><li><code>committed</code>：表示数据已经安全地保存在本地数据库中。</li></ul></li></ul><p>This leads us to the three main sections of a Git project： the working tree, the staging area, and the<br>Git directory.</p><p>基本的 Git 工作流程如下：</p><ol><li>在工作区中修改文件。</li><li>将你想要下次提交的更改选择性地暂存，这样只会将更改的部分添加到暂存区。</li><li>提交更新，找到暂存区的文件，将快照永久性存储到 Git 目录。</li></ol><h4 id="Git-Setup"><a href="#Git-Setup" class="headerlink" title="Git Setup"></a>Git Setup</h4><ol><li><p>Your Identity</p><p>设置你的用户名和邮件地址</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config [--global] user.name <span class="string">"John Doe"</span></span><br><span class="line">$ git config [--global] user.email <span class="string">"johndoe@example.com"</span></span><br></pre></td></tr></table></figure><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p></li><li><p>Checking Your Settings</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出所有 Git 当时能找到的配置</span></span><br><span class="line">$ git config --list</span><br></pre></td></tr></table></figure></li></ol><h4 id="get-a-Git-Repository"><a href="#get-a-Git-Repository" class="headerlink" title="get a Git Repository"></a>get a Git Repository</h4><p>通常有两种获取 Git 项目仓库的方式：</p><ol><li>将尚未进行版本控制的本地目录转换为 Git 仓库；</li><li>从其它服务器 <strong>克隆</strong> 一个已存在的 Git 仓库。</li></ol><hr><ol><li><p>Initializing a Repository in an Existing Directory</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /c/user/my_project</span><br></pre></td></tr></table></figure><p>在当前目录新建一个Git代码库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure></li><li><p>Cloning an Existing Repository</p><ul><li>Git 克隆的是该 Git 仓库服务器上的几乎所有数据，而不是仅仅复制完成你的工作所需要文件。</li></ul><p>克隆仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/libgit2/libgit2</span><br></pre></td></tr></table></figure><p>这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 <code>.git</code> 文件夹， 从远程仓库拉取下所有数据放入 <code>.git</code> 文件夹，然后从中读取最新版本的文件的拷贝。 </p><p>如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以通过额外的参数指定新的目录名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/libgit2/libgit2 mylibgit</span><br></pre></td></tr></table></figure><p>这会执行与上一条命令相同的操作，但目标目录名变为了 <code>mylibgit</code>。</p></li></ol><h4 id="Tracked-vs-Untracked-Files"><a href="#Tracked-vs-Untracked-Files" class="headerlink" title="Tracked vs. Untracked Files"></a>Tracked vs. Untracked Files</h4><p>The Git documentation has an excellent section on <a href="http://git-scm.com/book/en/Git-Basics-Recording-Changes-to-the-Repository" target="_blank" rel="noopener">recording changes</a>. An image from that section is placed here for your convenience:</p><ul><li>如上图所示，你工作目录下的每一个文件都不外乎这两种状态：<strong>tracked</strong> 或 <strong>untracked</strong>。 </li></ul><p>The following Git command allows you see the status of each file, i.e. whether it is untracked, unmodified, modified, or stageds:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br></pre></td></tr></table></figure><h4 id="Staging-amp-Committing"><a href="#Staging-amp-Committing" class="headerlink" title="Staging &amp; Committing"></a>Staging &amp; Committing</h4><p>A <em>commit</em> is a specific snapshot of your working directory at a particular time. Users must specify what exactly composes the snapshot by <em>staging</em> files.</p><p>The <code>add</code> command lets you stage a file.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line">$ git add [dir]</span><br></pre></td></tr></table></figure><p><code>git add</code> 命令使用文件或目录的路径作为参数；</p><ul><li>如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。</li></ul><p>Once you have staged all the files you would like to include in your snapshot, you can commit them as one block with a message.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m MESSAGE</span><br></pre></td></tr></table></figure><p>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。</p><p> you can use the log command:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>The Git reference guide has a helpful section on <a href="http://git-scm.com/book/en/Git-Basics-Viewing-the-Commit-History" target="_blank" rel="noopener">viewing commit history</a> and filtering log results when searching for particular commits. It might also be worth checking out <code>gitk</code>, which is a GUI prompted by the command line.</p><h4 id="Undoing-Changes"><a href="#Undoing-Changes" class="headerlink" title="Undoing Changes"></a>Undoing Changes</h4><p>The Git reference has a great section on <a href="http://git-scm.com/book/en/Git-Basics-Undoing-Things" target="_blank" rel="noopener">undoing things</a>. Please note that while Git revolves around the concept of history, it is possible to lose your work if you revert with some of these undo commands. Thus, be careful and read about the effects of your changes before undoing your work.</p><ul><li>Unstage a file that you haven’t yet committed:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git reset HEAD [file]</span><br></pre></td></tr></table></figure><p>This will take the file’s status back to modified, leaving changes intact. Don’t worry about this command undoing any work. This command is the equivalent of deleting one of the temporary images that you’re going to combine into a panorama.</p><p>Why might we need to use this command? Let’s say you accidentally started tracking a file that you didn’t want to track. (an embarrassing video of yourself, for instance.) Or you were made some changes to a file that you thought you would commit but no longer want to commit quite yet.</p><ul><li>Amend latest commit (changing commit message or add forgotten files):</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git add [forgotten-file]</span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><p>Please note that this new amended commit will replace the previous commit.</p><ul><li>Revert a file to its state at the time of the most recent commit:</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- [file]</span><br></pre></td></tr></table></figure><p>This next command is useful if you would like to actually undo your work. Let’s say that you have modified a certain <code>file</code> since committing previously, but you would like your file back to how it was before your modifications.</p><hr><h3 id="Remote-Repositories"><a href="#Remote-Repositories" class="headerlink" title="Remote Repositories"></a>Remote Repositories</h3><h4 id="Adding-Remotes"><a href="#Adding-Remotes" class="headerlink" title="Adding Remotes"></a>Adding Remotes</h4><p>Adding a remote repository means that you are telling git where the repo is located. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add [short-name] [remote-url]</span><br></pre></td></tr></table></figure><p>The remote URL will look something like <code>https://github.com/berkeley-cs61b/skeleton.git</code> if you are using HTTP or <code>git@github.com:berkeley-cs61b/skeleton.git</code> if you are using SSH.</p><p>By convention, the name of the primary remote is called <code>origin</code> (for original remote repository). So either of the following two commands would allow me to add the <code>berkeley-cs61b/skeleton</code> repository as a remote.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin https://github.com/berkeley-cs61b/skeleton.git</span><br><span class="line">$ git remote add origin git@github.com:berkeley-cs61b/skeleton.git</span><br></pre></td></tr></table></figure><p>After adding a remote, all other commands use its associated short name.</p><h4 id="Renaming-Deleting-amp-Listing-Remotes"><a href="#Renaming-Deleting-amp-Listing-Remotes" class="headerlink" title="Renaming, Deleting, &amp; Listing Remotes"></a>Renaming, Deleting, &amp; Listing Remotes</h4><ul><li><p>You can rename your remote by using this command:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rename [old-name] [new-name]</span><br></pre></td></tr></table></figure></li><li><p>You can also remove a remote if you are no longer using it:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm [remote-name]</span><br></pre></td></tr></table></figure></li><li><p>To see what remotes you have, you can list them. The <code>-v</code> flag tells you the URL of each remote (not just its name).</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br></pre></td></tr></table></figure></li></ul><p>You can read more about <a href="http://git-scm.com/book/en/Git-Basics-Working-with-Remotes" target="_blank" rel="noopener">working with remotes</a> in the Pro Git book.</p><h4 id="Cloning-a-Remote"><a href="#Cloning-a-Remote" class="headerlink" title="Cloning a Remote"></a>Cloning a Remote</h4><p>There are often remote repos with code that you would like to copy to your own computer. In these cases, you can easily download the entire repo with its commit history by cloning the remote:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> [remote-url]</span><br><span class="line">$ git <span class="built_in">clone</span> [remote-url] [directory-name]</span><br></pre></td></tr></table></figure><p>The top command will create a directory of the same name as the remote repo. The second command allows you to specify a different name for the copied repository.</p><p>When you clone a remote, the cloned remote because associated with your local repo by the name <code>origin</code>. This is by default because the cloned remote was the <code>origin</code> for your local repo.</p><h4 id="Pushing-Commits"><a href="#Pushing-Commits" class="headerlink" title="Pushing Commits"></a>Pushing Commits</h4><p>You may wish to update the contents of a remote repo by adding some commits that you made locally. You can do this by <code>pushing</code> your commits:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push [remote-name] [remote-branch]</span><br></pre></td></tr></table></figure><p>Note that you will be pushing to the remote branch from the branch your <code>HEAD</code> pointer is currently referencing. For example, let’s say that I cloned a repo then made some changes on the <code>master</code> branch. I can give the remote my local changes with this command:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure><h4 id="Fetching-amp-Pulling-Commits"><a href="#Fetching-amp-Pulling-Commits" class="headerlink" title="Fetching &amp; Pulling Commits"></a>Fetching &amp; Pulling Commits</h4><p>There are also times that you’d like to get some new commits from a remote that are not currently on your local repo. For example, you may have cloned a remote created by a partner and wish to get his/her newest changes. You can get those changes by fetching or pulling from the remote.</p><ul><li><p><code>fetch</code>: This is analogous to downloading the commits. It does not incorporate them into your own code.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch [remote-name]</span><br></pre></td></tr></table></figure><p>Why might you use this? Your partner may have created some changes that you’d like to review but keep separate from your own code. Fetching the changes will only update your local copy of the remote code but not merge the changes into your own code.</p><p>For a more particular example, let’s say that your partner creates a new branch on the remote called <code>fixing-ai-heuristics</code>. You can view that branch’s commits with the following steps:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch origin</span><br><span class="line">$ git branch review-ai-fix origin/fixing-ai-heuristics</span><br><span class="line">$ git checkout review-ai-fix</span><br></pre></td></tr></table></figure><p>The second command creates a new branch called <code>review-ai-fix</code> that <em>tracks</em> the <code>fixing-ai-heuristics</code> branch on the <code>origin</code> remote.</p></li><li><p><code>pull</code>: This is equivalent to a <code>fetch + merge</code>. Not only will <code>pull</code> fetch the most recent changes, it will also merge the changes into your <code>HEAD</code> branch.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull [remote-name] [remote-branch-name]</span><br></pre></td></tr></table></figure><p>Let’s say that my boss partner has pushed some commits to the <code>master</code> branch of our shared remote that fix our AI heuristics. I happen to know that it won’t break my code, so I can just pull it and merge it into my own code right away.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git pull origin master</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="Extra-Reading"><a href="#Extra-Reading" class="headerlink" title="Extra Reading"></a>Extra Reading</h3><ol><li><a href="http://git-scm.com/doc" target="_blank" rel="noopener">Git Documentation</a> is really quite good and clear, and there is a great Pro Git book by Scott Chacon.</li><li><a href="http://wildlyinaccurate.com/a-hackers-guide-to-git" target="_blank" rel="noopener">Hacker’s Guide to Git</a> is a very friendly introduction to how Git works. It gives a peek at the structure of commits &amp; branches and explains how some commands work.</li><li><a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/" target="_blank" rel="noopener">Git Magic</a> is a fun and useful turtorial.</li><li><a href="https://sp19.datastructur.es/materials/guides/using-git.html" target="_blank" rel="noopener">Using Git Guide</a> is very good and friendly to beginners, and written by Sarah Kim. <ul><li>本文其实是这篇文章的总结归纳。</li></ul></li><li><a href="https://backlog.com/git-tutorial/cn/" target="_blank" rel="noopener">猴子都能懂的GIT入门</a>：寓教于乐。</li><li><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">Git教程</a>：廖雪峰老师的Git教学。</li><li><a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html" target="_blank" rel="noopener">Git cheat sheet</a>：阮一峰老师总结的常用Git命令清单，非常实用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> wiki </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/06/14/hello-world/"/>
      <url>/2020/06/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
