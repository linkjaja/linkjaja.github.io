[{"title":"剑指 Offer II 004. 只出现一次的数字","date":"2022-06-07T06:37:32.000Z","url":"/2022/06/07/jzii004/","tags":[["Bitwise","/tags/Bitwise/"],["Bitwise_Bit Shifting","/tags/Bitwise-Bit-Shifting/"],["Set","/tags/Set/"],["HashTable","/tags/HashTable/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。 src： 例子： 注意 1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 104 -231&lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1 nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 进阶：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ SolutionsSolution 1 (数学方法，set)nums 除了目标元素只出现 1 次，剩余的每个元素都出现 3 次，那么可以利用 set 去重来做题。 Work &amp; ThoughtsumDistinct * 3 - sum &#x3D; target * 2； Code Afterthought易错点: 在计算 target 的值时，将会溢出 int 的边界，所以先放到 long 类型的变量里面； time complexity: O(n)，遍历 nums 数组； space complexity: O(n)，存放到 set 中占用的空间； Solution 2 (hashtable)nums 除了目标元素只出现 1 次，剩余的每个元素都出现 3 次，可以用 hashtable 来打表查表。 Work &amp; Thought用哈希表计数，先遍历数组放，后遍历哈希表查次数为1的key。 key value 数值 出现次数 Code Afterthought易错点: for each 的写法，关于遍历 hashmap（通过map.keySet()）； JDK 1.8 开始可以用 getOrDefault(key, default value)，在要赋默认值的场景下很好用； time complexity: O(n)，遍历 nums 数组； space complexity: O(n)，存放到 hashmap 中占用的空间； Solution 3 (bit wise, bit shifting)不占用额外的空间。 二进制的数，比如 1001，出现 3 次，若记录 1 出现的次数，为 3003，之后对其进行 mod 3 操作，就没有余数。 Work &amp; Thought根据题目，-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231- 1，我们可以创建一个 32 位长度的数组 cnt[]，用来记录所有数值的每一位共出现了多少次 1，之后对 cnt[] 数组的每一位进行 mod 3 操作，就可以得到只出现 1 次的值。 Code Afterthought 运算符的优先级 &gt;&gt; ， &amp; &gt;&gt; 优先于 &amp; ，所以(cur &gt;&gt; i) &amp; 1不加括号也对 % ，&amp; % 优先于 &amp;，也就是乘除优先于逻辑 &lt;&lt; ， += &lt;&lt; 优先于 += ，也就是位优先于赋值，所以ans += (1 &lt;&lt; i)不加括号也对 数每一位出现1的次数，可用移位cur &gt;&gt; i == 1 来实现； time complexity: O(n)，遍历 nums 数组； space complexity: O(1)，常数的空间申请； Reference qingfengpython 链接： "},{"title":"剑指 Offer II 003. 前 n 个数字二进制中 1 的个数","date":"2022-06-06T13:42:09.000Z","url":"/2022/06/06/jzii003/","tags":[["Bitwise","/tags/Bitwise/"],["Bitwise_Bit Shifting","/tags/Bitwise-Bit-Shifting/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定一个非负整数 n ，请计算 0 到 n 之间的每个数字的二进制表示中 1 的个数，并输出一个数组。 src： 例子： 注意 0 &lt;= n &lt;= 105 进阶: 给出时间复杂度为 O(n*sizeof(integer)) 的解答非常容易。但你可以在线性时间 O(n) 内用一趟扫描做到吗？ 要求算法的空间复杂度为 O(n) 。 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount ）来执行此操作。 SolutionsSolution 1 (bit wise)i &amp; (i - 1) 可以消去最低位的 1 ，我们可以使用这种方法来计数。 Code Afterthought易错点: 运算符的优先级 &amp; and - - 优先于 &amp; ，所以这里i &amp; (i-1)可以没有括号； 数组的动态初始化，int[] c = new int[3]； time complexity: O(kn)， 假设计数时候的整数有k位； space complexity: O(1)； Solution 2 (iterate，bit wise optimazed)solution 1 是根据 i &amp; (i - 1) 可以消去最低位的 1 来计数，但需要对每一个数字（从 0-n）进行位数中的计数，是很浪费时间的。 Work &amp; Thought可以看出 i 和i &amp; (i - 1)的关联，即i 比i &amp; (i-1)多了一个最右边的1，举例，1110 比 1100 多一个1，也就是 14 比 12 多一个1。利用这点，就可以以小推大。 Code Afterthought易错点: 运算符的优先级 &amp; and - - 优先于 &amp; ，所以这里i &amp; (i-1)可以没有括号； 数组的动态初始化，int[] c = new int[3]； time complexity: O(n)； space complexity: O(1)； 迭代的思想。 Solution 3 (iterate，bit shifting，bit wise optimazed)如果要以小推大，就要建立起关联，我们可以发现，i 与 i &gt;&gt; 1 存在联系。 Work &amp; Thoughti 与 i &gt;&gt; 1存在联系： 如果 i 最低位为 0，即 i 为偶数，那么 i 与 i &gt;&gt; 1 二进制 1 的个数相同； 如果 i 最低位为 1，即 i 为奇数，那么 i 比 i &gt;&gt; 1 多一个1； 奇偶的判定：x &amp; 1，x 为偶数，结果为 0；x 为奇数，结果为 1； 那么，就可以列出式子：arr[i] = arr[i &gt;&gt; 1] + (i &amp; 1)； Code Afterthoughttime complexity: O(n)； space complexity: O(1)； 迭代的思想。 "},{"title":"剑指 Offer II 002. 二进制加法","date":"2022-06-06T07:06:05.000Z","url":"/2022/06/06/jzii002/","tags":[["Simulation","/tags/Simulation/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定两个 01 字符串 a 和 b ，请计算它们的和，并以二进制字符串的形式输出。 输入为 非空 字符串且只包含数字 1 和 0。 src： 例子： 注意 每个字符串仅由字符 &#39;0&#39; 或 &#39;1&#39; 组成。 1 &lt;= a.length, b.length &lt;= 10^4 字符串如果不是 &quot;0&quot; ，就都不含前导零。 SolutionsSolution 1 (brute force, simulation)题目要求实现加法，第一个想法是把传入参数直接加，但是是二进制，所以想到用模拟加法来做这道题（下图）。 Work &amp; Thought从右到左一位位地进行计算，把每一位的计算结果 append 到返回的结果 String（先放在可变字符串 StringBuilder），最后 reverse，也转成题目要求的 String。 指针 i，j 来指正在计算的位，读到的数据分别存到 digitA，digitB，输出结果存到 StringBuilder（可变，不同步）； 在逆序、返回结果前，记得把最后的 carry 加上； Code Afterthought易错点: i--，先引用后减去，即先让i所在的表达式中使用i的当前值，再让i减 1； 进位之后，记得 sum 要减去对应的进位，不然 sum 加到 result 上，后面就乱了； char 的 0、1 并不等同于 int 的 0、1，如果直接将 char 值 0 硬转为 int，得到的 int 值是 48，本题显然不是要 48，所以要减去 ‘0’； time complexity: O(max(M, N) )， 其中 M，N 为 a, b 数字长度，按位遍历一遍数字（以较长的数字为准）； space complexity: O(1)； 想到用模拟来做之后，思路清晰，这道题目还是很好写的，没什么难的。 "},{"title":"剑指 Offer II 001. 整数除法","date":"2022-05-31T12:46:28.000Z","url":"/2022/05/31/jzii001/","tags":[["Bitwise","/tags/Bitwise/"],["Simulation","/tags/Simulation/"],["Bitwise_Bit Shifting","/tags/Bitwise-Bit-Shifting/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定两个整数 a 和 b ，求它们的除法的商 a/b ，要求不得使用乘号 &#39;*&#39;、除号 &#39;/&#39; 以及求余符号 &#39;%&#39; 。 src： 例子： 注意 整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2； 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231−1]。本题中，如果除法结果溢出，则返回 231 − 1； -231 &lt;&#x3D; a, b &lt;&#x3D; 231 - 1； b !&#x3D; 0； SolutionsSolution 1 (brute force) 不进行模拟，也不进行位运算。直观。 题目要求a除以b的商，且截去小数部分，可以理解为 a 等价于 n * b + c（c &lt; b），用减法来实现乘法。 思想很简单，但是实现的时候要注意： 越界问题，int 类型的范围； 返回结果的正负号，计算的环境（正 or 负）； Work &amp; Thought 越界的讨论，本题是整数除法（c must &lt;&#x3D; a），所以溢出的情况只有一个，就是 −231 &#x2F; -1，它的结果 231 越界了，根据题目，需要特殊处理返回231 − 1； 还有一种情况，如果是在正数的计算环境中，a&#x3D;−231，a在转变成正数的时候，变成231，溢出了。所以，要么都变负数，要么特殊情况拎出来讨论。 结果的正负号，可以先记好，只有在它俩异号的时候商是负号，就是它俩一个负数 or 一个正数，用一个变量记下，之后统一计算的环境，进行计算； Code Afterthoughttime complexity: O( ) 难以具体地给出；space complexity: O(1)； 计算量太大，最坏情况如果a是 −231，b是 1，计算出商，需要算很多次。 在超时的边缘试探，leetcode 很难跑过。 特点是思路直观，因为 Java 语言的特点，需要考虑 int 越界这个因素，在结果输出和计算的时候都要考虑到这一点，是本题的难点。 Solution 2 (bit wise &amp; simulation)Work &amp; Thought 对于 int 越界问题，和 Solution 1 差不多的解法，先筛掉特殊情况，之后使用负数的计算环境； 如果要用正数计算环境，需要把传入的参数 a，b 强制转型为 long； 返回结果的正负号问题： 铺垫： 位运算的异或（不同是1）和与（同时为1是1），Integer.MIN_VALUE是负数，最高位为1； Integer.MIN_VALUE -2147483648 1-0000 0000 0000 0000 0000 0000 0000 000 a ^ b 解释：若a，b同号，0xxxx，若异号，1xxxx，这时和 Integer.MIN_VALUE 进行与运算，除了最高位，其它位均清0，得到结果 0（ab同号） or 1（ab异号）； 也可以这样：a ^ b &gt;&#x3D; 0，若大于0，就是异号，反之，就是同号，因为最高位是符号位； 相比于 Solution 1 的 flag，这个解法能体现位运算的知识储备。 simulation 部分：模拟除法的手写算式（二进制），本质还是减法，但是里面的一层用二进制，这样就可以用移位运算，省到log级别的时间复杂度。 Code Afterthoughttime complexity: O( logn) 难以具体地给出；space complexity: O(1)； 针对 int 越界的问题，用了 long，一些情况下可能会限制使用 long。 跑很快。 特点是移位运算，里面的一层循环要理清，算是难点。 商的正负号判断，相比于对 a，b 进行大于 0 小于 0 来说亮眼了，但是普通方法也是完全可以的。 Amended version of Solution2题目说我们的环境只能存储 32 位有符号整数，所以理论上，使用 long 是不被允许的。 位运算的环境改成 负数 就可以。 Code"},{"title":"Git 向导","date":"2021-05-04T21:40:14.000Z","url":"/2021/05/05/git-guide/","categories":[["Git","/categories/Git/"]],"content":"Git 是什么？Git 是一个分布式版本控制系统（Distributed Version Control System），客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。 四个特点： 直接记录快照，而非差异比较； 近乎所有操作都是本地执行； Git 保证完整性； Git 一般只添加数据； Git 的工作流程 （Git - Workflow 来源：阮一峰的网络日志） 专业名词基本的 Git 工作流程： 在工作区（Workspace）中修改文件； 将更改选择性暂存至暂存区（Staging area&#x2F; Index）； 提交暂存区的内容到本地仓库（Repository）； Git 的三种状态，文件可能处于其一，假设这个文件是README.md，那么它为： modified：修改了文件，但修改仅在工作区； staged：将工作区已修改的文件放到了暂存区； committed：文件已经安全地保存到本地仓库。 配置 设置提交代码时的用户信息： 检查设定： 配置文件的路径： 本地仓库配置对应的配置文件路径 [–local] ： 用户全局配置对应的配置文件路径 [–global] ： 系统配置对应的配置文件路径[–system]： 新建代码库From existing data From existing repository注意：Git 克隆的是远程 Git 仓库的几乎所有数据，不仅仅是最新的版本。 本地变动 – git status列出哪些文件已被暂存、未被暂存、未被跟踪，即查看工作目录下的文件处于什么状态： 添加指定文件到暂存区，即将该文件放到暂存区（new file）： 也可以用上面的这条指令来暂存已被跟踪文件的最新修改（modified）； 如果对暂存后的文件再次进行修改，之后查询文件状态，那么这时，这个文件将会同时出现在 staging area 和 workspace，因为最新的修改还在工作区，没有暂存，而之前 git add 的版本被暂存了，如果这时提交，那么本地仓库的版本将会是最后一次 git add 的版本，不包含 workspace 中最新的修改。 本地变动 – git diff列出追踪但尚未暂存的文件更新了哪些部分，即工作区和暂存区的差异： 注意：git diff 不能显示自从上次提交的所有变化，它只能显示尚未暂存的变化。如果已经把所有修改的内容都暂存了，那么 git diff 不会有任何反馈。 列出已经暂存，但是没有提交到本地仓库的变化，即暂存区和上一个 commit 的差异： 列出工作区和上一个 commit 的差异（当前分支最新commit）： 列出两次 commit 之间的差异： 本地变动 – git add添加当前目录的所有文件到暂存区： 注意：如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。 对于同一个文件的多处变化，可以实现分次提交： 可以更好地利用 git commit 的注释功能，使仓库的版本颗粒度更高，可读性更好。 参考： stack overflow：Commit only part of a file in Git Git docs：git-add manpage 本地变动 – git rm删除工作区文件，并且将这次删除放入暂存区： 停止追踪指定文件，但该文件会保留在工作区： 比如删除添加.gitignore文件前错误提交的文件。 本地变动 – git mv移动文件，并将这个移动放入暂存区（也可以理解为文件改名）： 参考： Git docs：git-mv manpage 提交到本地仓库 – git commit提交暂存区到本地仓库： 也可以指定暂存区的文件提交到本地仓库，只要在 commit 后面指定 file。 跳过暂存区，直接将工作区自上次 commit 之后的变化，提交到本地仓库： 使用一次新的 commit，替代上一次提交： 重做上一次 commit，并包括指定文件的新变化： 参考： Git docs：git-commit manpage 提交到本地仓库 – git log列出当前分支的版本历史： 仅列出包含指定文件修改的 commit： 限制 log 的显示数量： 列出所有提交，每行显示一条 commit（仅显示提交的 hash 和 message）： 按提交者名字搜索并显示 commit： 按指定内容搜索并显示 commit： 显示图形化的 branch 信息： 参考： Git docs：git-log manpage 提交到本地仓库 – git reflog列出本地仓库的所有 commit： 提交到本地仓库 – git blame列出指定文件是什么人在什么时间修改过： 也可以具体查文档内部某一部分是谁修改： 参考： Git docs：git-blame manpage 远程仓库 – 拉取到本地拉取远程仓库的所有变动到本地，但不合并： 拉取远程仓库特定分支的更新到本地，不合并： 拉取远程仓库的所有变动到本地，之后自动与 HEAD 版本合并： 拉取远程仓库的所有变动到本地，并以 rebase 模式并入本地仓库： 列出当前配置的所有远程端： 如果远程仓库不止一个，那么就会全部列出，比如和多个协作者合作的，这样可以非常方便地拉取其他用户的贡献，还拥有向他们推送的权限。 显示某个远程端的信息： 增加一个新的远程仓库，并指定简写： 远程仓库 – 推送到远程上传本地指定分支到远程仓库： 注意：只有当有推送到该远程仓库的权限，及之前没有人推送过时，该命令才有效。如果有他人先推送到上游，那么，此时的推送命令就会被拒绝，必须先抓取他们的工作并将其合并到本地仓库，才能推送。 参考： Git book：remote branches 分支 – git branch列出本地仓库的所有分支： 列出所有远程分支： 列出所有本地分支和远程分支： 新建一个分支，但依然停留在当前分支： 新建一个分支，并切换到该分支： 新建一个分支，指向指定 commit： 新建一个分支，与指定的远程分支建立追踪关系： 建立追踪关系，在现有分支与指定的远程分支之间： 切换到指定分支，并更新工作区： 切换到上一个分支： 合并指定分支到当前分支： 选择一个 commit，合并进当前分支： 删除分支： 若该分支的修改尚未合并，那么用 -D 参数来强制删除分支，注意，该操作会丢失未合并的修改。 删除远程分支： 分支 – git rebase基于 base 对当前分支进行 rebase。base 可以是 commit、分支名称、tag 或者相对于 HEAD 的 commit。 参考： Git docs：git-rebase manpage B站视频：git-rebase 图解 回滚 – git revert新建一个 commit，用来撤销指定 commit，并且应用到当前分支： 回滚 – git checkout恢复暂存区的指定文件到工作区： 恢复某个 commit 的指定文件到暂存区和工作区： 恢复暂存区的所有文件到工作区： 回滚 – git reset重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变，即撤销这个文件上次的 git add： 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变： 重置暂存区与工作区，与上一次 commit 保持一致： 重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致： 重置当前HEAD为指定 commit，但保持暂存区和工作区不变： 暂时将未提交的变化移除，稍后再移入： 回滚 – 具体场景场景1. 已经提交内容到本地仓库 如何回滚？ 场景2. 修改了还未提交到暂存区 怎么撤销？ 补充： 一种是该文件自修改后还没有放到暂存区，那么，现在撤销修改，就是回到和版本库一模一样的状态； 另一种是该文件添加到暂存区后，又做了修改，那么现在撤销修改，就是回到添加到暂存区后的状态； 场景3. 提交到暂存区，但还未提交到本地仓库 怎么办？ 把暂存区的修改撤销（unstage），重新放回工作区。 所以， git reset 既可以回退版本，也可以把暂存区的修改回退到工作区。 之后，丢弃工作区的修改即可。 标签列出所有标签： 给当前版本打标签： 给指定 commit 打标签： 删除本地标签： 删除远程标签： 提交指定标签： 提交所有标签： 新建一个分支，指向某个标签： Git 的 GUI 工具SourceTreeSourceTree 官网 IntelliJ IDEA 中的 GitIntelliJ IDEA 官方文档 相关链接 Pro Git book by Scott Chacon and Ben Straub. The book is available online for free at git-scm.com&#x2F;book. 常用 Git 命令清单：阮一峰的网络日志. Git Cheat Sheet: made by Hylke Bons. Git Cheat Sheet 中文版: translated by Gevin. "},{"title":"categories","date":"2022-04-06T16:36:46.000Z","url":"/categories/index.html","categories":[[" ",""]]},{"title":"search","date":"2022-04-06T16:11:22.000Z","url":"/search/index.html","categories":[[" ",""]]},{"title":"tags","date":"2022-04-06T16:35:46.000Z","url":"/tags/index.html","categories":[[" ",""]]}]