[{"title":"剑指 Offer II 042. 最近请求次数","date":"2022-10-24T06:57:21.000Z","url":"/2022/10/24/jzii042/","tags":[["Queue","/tags/Queue/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干写一个 RecentCounter 类来计算特定时间范围内最近的请求。 请实现 RecentCounter 类： RecentCounter() 初始化计数器，请求数为 0 。 int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。保证 每次对 ping 的调用都使用比之前更大的 t 值。 easy src： SolutionsSolution 1 (queue)Thought因为每次收到请求的时间都比之前的大。因此 t 是单调递增的。那么求 [t−3000,t]内发生的请求数，可以用一个队列，先进的先出，即早于 t - 3000 的请求出队，之后计算队列长度即可。FIFO Code Afterthoughttime complexity: O(1)，每个元素至多入队出队各一次。space complexity: O(n)"},{"title":"剑指 Offer II 041. 滑动窗口的平均值","date":"2022-10-24T06:57:19.000Z","url":"/2022/10/24/jzii041/","tags":[["Queue","/tags/Queue/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定一个整数数据流和一个窗口大小，根据该滑动窗口的大小，计算滑动窗口里所有数字的平均值。 实现 MovingAverage 类： MovingAverage(int size) 用窗口大小 size 初始化对象。double next(int val) 成员函数 next每次调用的时候都会往滑动窗口增加一个整数，请计算并返回数据流中最后 size个值的移动平均值，即滑动窗口里所有数字的平均值。 easy src： SolutionsSolution 1 (queue)ThoughtFIFO，计算队列当中的均值。 Code 1(ArrayDeque 实现 queue) Code 2 (数组模拟 queue) Afterthoughttime complexity: O(m), m 为 next 操作的次数space complexity: O(n)"},{"title":"剑指 Offer II 040. 矩阵中最大的矩形","date":"2022-10-24T06:55:47.000Z","url":"/2022/10/24/jzii040/","tags":[["Stack","/tags/Stack/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定一个由 0 和 1 组成的矩阵 matrix ，找出只包含 1 的最大矩形，并返回其面积。 注意：此题 matrix 输入格式为一维 01 字符串数组。hard src： SolutionsSolution 1 (单调栈)Thought和 39题 是一类问题。这次每一行可以找出一个 maxArea。我们定义一个 heights 数组，记录元素1从当前层到顶层的距离。构成了39题的直方图形状，通过单调栈计算 area 即可。 heights 数组图示 注意：stack 中存的是 height 元素的下标。 Code Afterthoughttime complexity: O(n)space complexity: O(n)"},{"title":"剑指 Offer II 039. 直方图最大矩形面积","date":"2022-10-24T06:55:43.000Z","url":"/2022/10/24/jzii039/","tags":[["Stack","/tags/Stack/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定非负整数数组 heights，数组中的数字用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。hard src： SolutionsSolution 1 (单调栈)Thought 这样遍历一次 height 就可以获得所有的 left 和 right，即遍历一次就可以得到 maxArea。 width 是 height 数组长度的情况需要讨论。 Code 1 Stack Code 2 ArrayDeque用 Deque 实现 FILO Afterthoughttime complexity: O(n)space complexity: O(n) Reference"},{"title":"剑指 Offer II 038. 每日温度","date":"2022-10-24T06:55:41.000Z","url":"/2022/10/24/jzii038/","tags":[["Stack","/tags/Stack/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干请根据每日 气温 列表 temperatures，重新生成一个列表，要求其对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。medium src： SolutionsSolution 1 (单调栈)Thoughtstack 中存的是温度的下标，方便更新相差天数。如果入栈的时候遇到新高，就更新。如果不是新高，就入栈。 Code Afterthoughttime complexity: O(n)space complexity: O(n) Reference"},{"title":"剑指 Offer II 037. 小行星碰撞","date":"2022-10-24T06:55:39.000Z","url":"/2022/10/24/jzii037/","tags":[["Stack","/tags/Stack/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定一个整数数组 asteroids，表示在同一行的小行星。 对于数组中的每一个元素，其绝对值表示小行星的大小，正负表示小行星的移动方向（正表示向右移动，负表示向左移动）。每一颗小行星以相同的速度移动。 找出碰撞后剩下的所有小行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞。medium src： SolutionsSolution 1 (satck)Thought我们将场景分为 1. 入栈场景（push 即可 2. 碰撞场景（需要判断具体场景 x 记作任一正整数，假设 x 是一个当前元素 Code Afterthoughttime complexity: O(n)space complexity: O(n)"},{"title":"剑指 Offer II 036. 后缀表达式","date":"2022-10-24T06:55:36.000Z","url":"/2022/10/24/jzii036/","tags":[["Stack","/tags/Stack/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干根据 逆波兰表示法，求该后缀表达式的计算结果。有效的算符包括 +、-、*、&#x2F; 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。medium src： SolutionsSolution 1 (stack)Thought利用栈的 FILO 特性，若碰到数字就进栈，碰到运算符就将栈最上面的两个元素出栈，做运算后将运算结果入栈，最后栈中所剩元素，即整个后缀表达式的计算结果。 Code Afterthoughttime complexity: O(n)space complexity: O(n)"},{"title":"剑指 Offer II 035. 最小时间差","date":"2022-10-24T06:55:33.000Z","url":"/2022/10/24/jzii035/","tags":[["HashTable","/tags/HashTable/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定一个 24 小时制（小时:分钟 “HH:MM”）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。 medium src：ttps:&#x2F;&#x2F;leetcode-cn.com&#x2F;problems&#x2F;569nqc&#x2F; SolutionsSolution 1 (hashtable)Thought找出最小时间差，并以分钟形式表示。 21:03，22:01 都是 24小时制 HH:MM，把它们转化为分钟制： 调用 String 类的 split(String regex) 接口，把一个时间点转化为字符串数组，比如 [&quot;21&quot;, &quot;03&quot;]； 之后，进行分钟制的换算，调用 Integer 类的 valueOf(String s) 接口，得到一个 Integer 对象，之后计算即可。 注意： 时间点是双向的， 给定 21:03，01:00 两个时间点，最小时间差是 21:03 至午夜 1 点，就是要给 01:00 加上完整的 24h，让它变成第二天早上，这样就可以减去第一天的 21:03 了； 给定 01:03，01:00 两个时间点，最小时间差是凌晨 1 点至 01:03，这时可以直接相减； 所以，我们要将最小时间点追加 24h。 cornor case 的讨论： 一天有 60 * 24 分钟，如果 timePoint 数组长度超过了 60 * 24，那么肯定有重复的时间点，直接得到最小时间差为 0； 数组 minutes 的排序可以调用 ArrayList 类的 sort(Comparator&lt;? super E&gt; c) 接口，可以调用 Collections 类的 sort(List&lt;T&gt; list) 接口，可以手写快排。 Code 1 (快排调接口) Code 2 (手写快排) Afterthoughttime complexity: O(nlogn), n &#x3D; timePoints.lengthspace complexity: O(n)"},{"title":"剑指 Offer II 034. 外星语言是否排序","date":"2022-10-24T06:55:31.000Z","url":"/2022/10/24/jzii034/","tags":[["HashTable","/tags/HashTable/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干某种外星语也使用英文小写字母，但可能顺序 order 不同。字母表的顺序（order）是一些小写字母的排列。 给定一组用外星语书写的单词 words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时，返回 true；否则，返回 false。 easy src： SolutionsSolution 1 (hashtable)Thought判断 words 是否按 order 排列。 用 hashtable 保存 order 中各个字符对应的字典序，键值对&lt;字母，对应字典序&gt;； 注意： 一长一短的两个 word，比如 abb，ab，空白字符最小，所以 ab 应该在前，那么我们在对比的时候，先确定短字符串的长度 minLen，遍历完 minLen 后，看在前的是不是较长的字符串，如果在前且还没有得到相同位置后一个字符串比前一个字符串大，那就不符合 order。 在遍历过程中，要分开讨论：（记 dif 为当前字母的order - 前一个字母的order） Code Afterthoughttime complexity: n 为 words[i].length，m 为 words.length，O(mn)space complexity: O(1)，常数空间"},{"title":"剑指 Offer II 033. 变位词组","date":"2022-10-24T06:55:29.000Z","url":"/2022/10/24/jzii033/","tags":[["HashTable","/tags/HashTable/"],["Quick Sort","/tags/Quick-Sort/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定一个字符串数组 strs ，将 变位词 组合在一起。 可以按任意顺序返回结果列表。注意：若两个字符串中每个字符出现的次数都相同，则称它们互为变位词。medium src： SolutionsSolution 1 (hashtable)Thought找到变位词后，将变位词组合在一起。 变位词：每个字符的出现次数相同，但是顺序不完全相同。 先排序，之后一一存入 map，最后输出 map 中所有的数组（放到一个大数组里套娃）即可； 调用 HashMap 的 values() 接口，导出 map 的 collection 视图，获取集合中的所有的值—-没有键，没有对应关系。 字符串内部的字符排序可以调用 Arrays 类的 sort() 接口，原理是快排，也可以手写快排。 变位词排序后形成的字符串， 可以通过 String 类的 valueOf() 接口，得到这个 char 数组的 String representation， 也可以通过 String 类的构造方法 String(char[] value) 来得到。 Code 1 （快排调接口） Code 2 （手写快排） Afterthoughttime complexity: n 为 strs[i].length，m 为 strs.length，O(m * nlogn)space complexity: O(mn)，原来放 strs 中的需要都放到 map 中，所占用的空间"},{"title":"剑指 Offer II 032. 有效的变位词","date":"2022-10-24T06:55:27.000Z","url":"/2022/10/24/jzii032/","tags":[["HashTable","/tags/HashTable/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定两个字符串 s 和 t ，编写一个函数来判断它们是不是一组变位词（字母异位词）。 注意：若 s 和 t 中每个字符出现的次数都相同且字符顺序不完全相同，则称 s 和 t 互为变位词（字母异位词）。easy src： SolutionsSolution 1 (hashtable)Thoughthashtable map 存键值对 &lt;出现字符，次数&gt;， 题目中说 s 和 t 中都是小写字母，把小写字母转化为 0-25 的数字是可行的，这样就可以用数组实现（下标作为key，指代出现字符），节约一些常数空间。但是进阶版本是 unicode 字符，就还是用 hashtable 实现。 cornor case 的讨论： 题目中没有说 s 和 t 的长度相等，这个情况需要考虑；题目中也没有说 s 和 t 不会等价，这个情况需要考虑； Code（2 个 hashtable） Code（1 个 hashtable） Afterthoughttime complexity: O(n)space complexity: O(1)"},{"title":"剑指 Offer II 031. 最近最少使用缓存","date":"2022-10-24T06:55:24.000Z","url":"/2022/10/24/jzii031/","tags":[["HashTable","/tags/HashTable/"],["Quick Sort","/tags/Quick-Sort/"],["LinkedList","/tags/LinkedList/"],["Doubly Linkedlist 头插法","/tags/Doubly-Linkedlist-%E5%A4%B4%E6%8F%92%E6%B3%95/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干运用所掌握的数据结构，设计和实现一个 LRU (Least Recently Used，最近最少使用) 缓存机制 。 实现 LRUCache 类： LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存 int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。 void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。 medium src： SolutionsSolution 1 (设计-使用hashtable，doubly linkedlist)Thought实现一个 LRUCache 类，其中有 get(key), put(key, val) 方法。put 超过 capacity 就删除 least recently used 的元素。 time complexity 都要是 O(1); 根据以上，我们发现 LRUcache 需要满足：查找快，插入快，删除快，且有顺序。（数据结构见下图） 从 get(key)，联想到用 hashtable 来关联 key 和 val，实现快速查找。 每次访问完，要把数据插到队头，快速插入用链表来实现。 放数据也是头插法，因为过载需要删除数据，所以用 doubly linkedlist，操作 prev，用前一个指向后一个来跳过当前数据。 需要注意： 链表中存的是 &lt;key, val&gt; 键值对，不只是 val，因为删掉不需要的元素后，在 map 中也要同步删掉，这时就需要通过链表中的 key 来定位 map 的 key。而且题目也明确说了存的是「关键字-值」。 首先，构建 doubly linkedlist 的节点类： 然后，依照节点构建一个 doubly linkedlist： 之后，把 doubly linkedlist 与 hashtable 结合，就可以实现 LRUCache： map 中已包含 key 的两种情况： Code Afterthoughttime complexity: O(1) Solution 2 (设计 - 调 LinkedHashMap)Thought 参考 Java 8： 参考题解： Code Afterthoughttime complexity: O(1)"},{"title":"剑指 Offer II 030. 插入、删除和随机访问都是 O(1) 的容器","date":"2022-10-21T06:36:36.000Z","url":"/2022/10/21/jzii030/","tags":[["HashTable","/tags/HashTable/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构： insert(val)：当元素 val 不存在时返回 true ，并向集合中插入该项，否则返回 false 。remove(val)：当元素 val 存在时返回 true ，并从集合中移除该项，否则返回 false 。getRandom：随机返回现有集合中的一项。每个元素应该有 相同的概率 被返回。 medium src： SolutionsSolution 1 (设计-使用hashtable)Thought实现一个 RandomizedSet 类，其中有 insert(val), remove(val), getRandom() 方法。 time complexity 都要是 O(1); boolean insert(val) val 已存在，返回 false；val 不存在，insert val，返回 true； hashtable map 的 key, value 分别对应 val, index，用来快速定位 val 在 arr 中的位置； boolean remove(val) val 不存在，无法删除没有的元素，返回 false；val 存在，借助 map，得到它对应的 index，delete val，返回 true。 这样 arr 会有空位置，之后 getRandom() 时，概率会不均，所以，我们通过覆盖法来删，把原本在 arr 末尾的元素放到 val 的位置，并在 map 中更新它，之后便可以删掉 arr 的最后一个元素， 这时已经 “删掉” 了 val，所以 map 也需要更新，即删掉 val 的相关映射。 int getRandom() 随机返回数组中已有的元素； public int nextInt(int bound) between zero (inclusive) and bound (exclusive) ；  “Class Random - Java 8” Code Afterthoughttime complexity: O(1)space complexity: O(1)"},{"title":"剑指 Offer II 029. 排序的循环链表","date":"2022-10-21T06:36:33.000Z","url":"/2022/10/21/jzii029/","tags":[["Two Pointers","/tags/Two-Pointers/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定循环单调非递减列表中的一个点，写一个函数向这个列表中插入一个新元素 insertVal ，使这个列表仍然是循环升序的。 medium src： SolutionsSolution 1 (two pointers)Thought向排序的循环列表中插入新元素，使该列表仍为循环升序。 辅助变量： cur，hnext 保持移动； 遍历时插入的两种情况， 1） 一轮中能插入，nodeVal 在 [min, max] 区间内，那么只要满足 cur.val &gt;= node.val &gt;= hnext.val，就可以插入到 cur 后；2） 一轮中不能插入，nodeVal 不在 [min, max] 区间内，这时只能插到最后一个 maxNode 与 minNode 之间，我们需要定位最后一个 maxNode 的位置，再进行插入。 可以通过 maxDiff（其中 diff = cur.Val - cur.next.Val） 来确定最后一个 maxNode 位置，也可以通过比较，来不断更新 maxNode 和 minNode 来确定位置； Code Afterthoughttime complexity: O(n)space complexity: O(1)"},{"title":"剑指 Offer II 028. 展平多级双向链表","date":"2022-10-21T06:36:31.000Z","url":"/2022/10/21/jzii028/","tags":[["Stack","/tags/Stack/"],["DFS","/tags/DFS/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定位于列表第一级的头节点，请扁平化列表，即将这样的多级双向链表展平成普通的双向链表，使所有结点出现在单级双链表中。 medium src： SolutionsSolution 1 (stack iterate)Thought扁平化多层数据结构，变成普通的双向链表。 child 属性让链表立体，我们需要沿着它伸展的方向来扁平它。 利用栈FILO的特性，在每一次走到有子节点的节点时，把与它相连的下一个节点入栈，这样走完子链后，就能退回上一层。 用 Deque 来实现栈； 具体实现： 遍历时的两种情况， 1）有 child，先和 child 连接，再断开 child 关系； *连之前把原先的next入栈2）无 child，就继续走，直到最后一个，连上栈里的pop()；这样就可以展平多层次链表。 题目没说 head 一定不为空，所以考虑一下这个边界情况。 Code Afterthought额外占用了栈的线性空间，但是思路清晰。 time complexity: O(n) space complexity: O(n) Solution 2 (DFS)Thought扁平化多层数据结构，变成普通的双向链表。 用 DFS 来扁平化，连接传入 dfs 的两个节点，优先走 child 节点，以及走完子链后返回到上一层。 思路： dummy 用来返回结果，最后要断开 dummy 下一个节点的 prev 关系； 三个辅助变量：pre，cur，hnext；还有子链的最后一个节点 tail； dfs 方法中，先连接，后断开 child 关系； Code Afterthoughttime complexity: O(n) space complexity: O(n)，需要维护递归栈。"},{"title":"剑指 Offer II 027. 回文链表","date":"2022-10-21T06:36:28.000Z","url":"/2022/10/21/jzii027/","tags":[["Two Pointers","/tags/Two-Pointers/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定一个链表的 头节点 head ，请判断其是否为回文链表。 如果一个链表是回文，那么链表节点序列从前往后看和从后往前看是相同的。easy src： SolutionsSolution 1 (数组 + 对撞双指针)Thought判断给定链表是否为回文链表。 回文链表（下图）头尾元素相等，如果这些元素在数组当中，就简单很多。 我们使用 left，right 指针在数组上对撞，先把链表元素的值一一放到数组当中，之后用 left，right 对比。 Code Afterthought额外占用了数组的线性空间，但是思路很清晰。 time complexity: O(n) space complexity: O(n) Solution 2 (快慢双指针)Thought判断给定链表是否为回文链表。 如果把回文链表从中间断开，之后翻转后半段，发现这时的前后半段是吻合的。 思路： 我们先把原链表平分成前后两段，变成 a, b 两个链表，之后将后半段 b 翻转，这时 b 的头结点就是原链表的尾节点，原本不太方便比较的头尾，就可以按顺序进行比较。 简单说就是：1. 快慢指针分段，断开才算分了；2. 翻转后半段；3. 比较；（具体见图示） 像 a-&gt;b-&gt;null 这样的链表，我们希望 slow 走到 a 点，之后断开 a 向 b 的指向； 这时有两种方法： 创建一个 dummy 节点，让 fast、slow 从 dummy 开始走，而不是从 head 开始，这样 fast 走 2 格，从而 slow 走1格到 a 点； 不创建新的节点， fast、slow 还是从 head 走，改变 while 循环的条件来适应这类情况： fast != null and fast.next != null 😇 fast.next != null and fast.next.next != null 🙅‍♂️ 1. 快慢指针分段，断开： 先指定 slow 的下一个节点为后半段链表的头结点，之后通过 slow 指向 null，来断开前后两段。 2. 翻转后半段： cur, nxt 起初在头结点，pre 起初在头结点的前一个节点，可以视作在 dummy。 简单说就是 nxt 前进到 cur 的下一个节点（反转了就不能走了）， cur 指向前一个节点 pre（反转）， 之后 pre 前进到 cur， cur 前进到 nxt。直到 cur 走出链表跳出。 Code Afterthought快慢双指针分段，反转链表，比较两个链表，三个链表知识点合一，需要认知清楚。不需要额外的线性空间占用。 time complexity: O(n) space complexity: O(1)；"},{"title":"剑指 Offer II 026. 重排链表","date":"2022-10-21T06:36:25.000Z","url":"/2022/10/21/jzii026/","tags":[["Two Pointers","/tags/Two-Pointers/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定一个单链表 L 的头节点 head ，单链表 L 表示为： L0 → L1 → … → Ln-1 → Ln请将其重新排列后变为： L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → … 不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。medium src： SolutionsSolution 1 (数组 + 对撞双指针)Thought题目让我们交错地排列给定链表。 可以看到，变化后的链表把最后一个元素移到了第二位，也就是让第一个元素指向它，它指向原本第二位的元素（下图 2）。 因为 left，right 指针在数组上对撞比较方便，所以我们把链表的元素一一放到数组当中，之后用 left，right 指针实现元素的移位。 链表的排序： 链表元素的移位： 排序完之后，将尾节点指向 null； Code Afterthought额外占用了数组的线性空间，但是思路很清晰。 time complexity: O(n) space complexity: O(n) Solution 2 (快慢双指针)Thought题目让我们交错地排列给定链表。 可以看到，变化后的链表（下图 1）是在原链表的基础上，一头一尾地这样连接起来。 这就给了一个新的思路： 我们先把原链表平分成前后两段，变成 a, b 两个链表，之后将后半段 b 翻转，这时 b 的头结点就是原链表的尾节点，原本不太方便的一头一尾，就可以按顺序 a 一个，b 一个串起来。 简单说就是：1. 快慢指针分段，断开才算分了；2. 翻转后半段；3. 连接；（具体见图示） 1. 快慢指针分段，断开： 先指定 slow 的下一个节点为后半段链表的头结点，之后通过 slow 指向 null，来断开前后两段。 2. 翻转后半段： cur, nxt 起初在头结点，pre 起初在头结点的前一个节点，可以视作在 dummy。 简单说就是 nxt 前进到 cur 的下一个节点（反转了就不能走了）， cur 指向前一个节点 pre（反转）， 之后 pre 前进到 cur， cur 前进到 nxt。直到 cur 走出链表跳出。 3. 连接： 假设前半段链表为 a，后半段链表为 b。 要实现 a1 -&gt; b1 -&gt; a2 -&gt; b2，我们这么做 先指定一个 tmp，意义和 nxt 差不多，它用来指 b 段的路，b 的头结点指向 a 头结点的下一个节点，这样就实现了 b1 -&gt; a2，a 的头结点指向 b 头结点，这样就实现了 a1 -&gt; b1，之后，我们要让前后半段都进一步，head 前进到 newHead.next，newHead 前进到 tmp。直到 newHead 走出链表跳出。 Code Afterthought不需要额外的线性空间占用。 time complexity: O(n) space complexity: O(1)"},{"title":"剑指 Offer II 025. 链表中的两数相加","date":"2022-10-21T06:36:17.000Z","url":"/2022/10/21/jzii025/","tags":[["Stack","/tags/Stack/"],["head first 头插法","/tags/head-first-%E5%A4%B4%E6%8F%92%E6%B3%95/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定两个 非空链表 l1和 l2 来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。 可以假设除了数字 0 之外，这两个数字都不会以零开头。medium src： SolutionsSolution 1 (stack，头插法)Thought链表中的元素相加，高位在链表开始位置，加完返回一个新链表。 主要难点：加法需要从最低位对齐，而链表的特性只能左侧对齐（下图）。我们可以通过两种方式来解： 翻转链表，之后就可以从头开始加； 利用栈先进后出的特性，让链表元素一一进栈，走完为止，之后同步出栈，做加法（下图）； 当然，加完之后的元素也要低位在链表尾部，也就是新算出来的数去指向上一个算出来的数，像栈一样往里挤。这种插入新节点的方法就是头插法（下图）。 链表加法： 辅助栈： 头插法： 计算过程中可能要进位。 我们维护一个进位变量 carry，计算中有两种情况： 没算完：在计算下一位的时候加上 carry； 算完了：若此时 carry 不等于 0，那么这个 carry 就要当最高位； Code Afterthoughttime complexity: O(n) space complexity: O(n)"},{"title":"剑指 Offer II 024. 反转链表","date":"2022-10-21T06:36:14.000Z","url":"/2022/10/21/jzii024/","categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定单链表的头节点 head ，请反转链表，并返回反转后的链表的头节点。easy src： SolutionsSolution 1 (iteration)Thought求两相交链表的第一个交点。 反转链表。每个节点反转的具体思路： 几个辅助的变量： dummy dnext，因为 head 一直在前进，所以需要一个变量固定在头结点的位置。 hnext Code Afterthoughttime complexity: O(n) space complexity: O(1) Solution 2 (recursion)Thought反转链表。 递归的终止条件：走到最后一个节点了； 递归的拆解：就是往前走； 递归的入参，返回值：链表节点； 走到底，会返回到递归栈的上一层，也就是上一个节点，进行翻转操作，具体见下图： Code Afterthoughttime complexity: O(n) space complexity: O(n) Reference【手把手带你刷Leetcode力扣｜各个击破数据结构和算法｜大厂面试必备技能【已完结】-哔哩哔哩】 "},{"title":"剑指 Offer II 023. 两个链表的第一个重合节点","date":"2022-10-21T06:36:12.000Z","url":"/2022/10/21/jzii023/","tags":[["Two Pointers","/tags/Two-Pointers/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定两个单链表的头节点 headA 和 headB ，请找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。easy src： SolutionsSolution 1 (two pointers)Thought求两相交链表的第一个交点。 简单说就是 tail to head。 双指针来解（见下图） Code Afterthoughttime complexity: O(n) space complexity: O(1)"},{"title":"剑指 Offer II 022. 链表中环的入口节点","date":"2022-10-21T06:36:09.000Z","url":"/2022/10/21/jzii022/","tags":[["Two Pointers","/tags/Two-Pointers/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定一个链表，返回链表开始入环的第一个节点。medium src： SolutionsSolution 1 (快慢双指针)Thought求入环节点。 快慢双指针来解，具体思路见下图： 因为 fast 每次要走 2 步，所以要确保 fast.next != null，也就是保证链表至少有 2 个节点。 因为与运算 &amp;&amp; 是短路运算，所以把 fast != null 放前面。 Code Code（version 2）思路一样，不过这个是把 fast 放回头结点。 Afterthoughttime complexity: O(n)，slow 合计走了一圈。 space complexity: O(1)"},{"title":"剑指 Offer II 021. 删除链表的倒数第 n 个结点","date":"2022-10-21T06:36:06.000Z","url":"/2022/10/21/jzii021/","tags":[["Two Pointers","/tags/Two-Pointers/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。medium src： SolutionsSolution 1 (快慢双指针)Thought题目让我们删除链表的倒数第 n 个节点。 题中不是双向链表，所以不能通过从最后一个节点往回走来定位目标节点，但我们可以通过： 以 O(n) 的时间复杂度代价，走一遍给定的链表来得到链表长度，从而定位目标节点； 题目说只用一趟扫描实现，那就换个思路。 前后双指针，因为链表是定长的，那么让 p1 先走 n 步，之后 p1, p2 一起走，p1 撞墙时，p2 就是倒数第 n（下图示意）。 具体如图示 Code Afterthoughttime complexity: O(n) space complexity: O(1)"},{"title":"剑指 II-020. 回文子字符串的个数","date":"2022-10-21T06:36:04.000Z","url":"/2022/10/21/jzii020/","tags":[["Extend from Center","/tags/Extend-from-Center/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定一个字符串 s ，请计算这个字符串中有多少个回文子字符串。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。medium src： SolutionsSolution 1 (中心扩展法)Thoughts 中有多少个回文子字符串。 枚举每一个可能的中心，i, j 分别向两边扩展，i 指到的字符与 j 指到的字符相等时，继续走，否则停下（下图）。 实现要注意： 我们找到的回文字符串理论上有两种，一种有中心元素（中轴点，aba），一种没有中心元素（直接可对折，aa），这两种的扩展方式是有区别的； 有无中心元素的分开讨论： 有中心元素的回文子串，我们就从它的轴点扩展，起点 left = i, right = i； 没有中心元素的回文子串，如何我们还是从“中心元素”开始扩展，那么不可能有收获，所以我们站在河两岸，起点 left = i, right = i + 1； Code Afterthoughttime complexity: O(n2) space complexity: O(1)"},{"title":"剑指 II-019. 最多删除一个字符得到回文","date":"2022-10-21T06:35:59.000Z","url":"/2022/10/21/jzii019/","tags":[["Two Pointers","/tags/Two-Pointers/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定一个非空字符串 s，请判断如果 最多 从字符串中删除一个字符能否得到一个回文字符串。easy src： SolutionsSolution 1 (对撞双指针)Thought判断删掉一个字符后， s 是不是有效的回文串。 s 由小写英文字母组成。 删掉一个字符，也就是给一次对不上的机会。理论上来说，对不上时，可能是左侧的字符需要走，也可能是右侧的字符需要走。 那么针对这种情况，我们再写个方法，专门用来判断已经用掉机会（没机会了）的这段是回文与否。 传入这段的左右边界来定位它。 Code Afterthoughttime complexity: O(n) space complexity: O(1)"},{"title":"剑指II-018. 有效的回文","date":"2022-10-21T06:35:45.000Z","url":"/2022/10/21/jzii018/","tags":[["Two Pointers","/tags/Two-Pointers/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定一个字符串 s ，验证 s 是否是 回文串 ，只考虑字母和数字字符，可以忽略字母的大小写。 本题中，将空字符串定义为有效的 回文串 。medium src： SolutionsSolution 1 (对撞双指针)Thought判断 s 是不是有效的回文串。 使用对撞双指针，i 从左出发，j 从右出发，一一比对，直到它俩相遇即可。 有对不上的就证明不是回文。 题中让我们只考虑字母和数字，并且忽略字母的大小写，也就是说： 遇到不是字母或数字的字符，我们就跳过 - Character.isLetterOrDigit(char ch)； 比对时，需要转化为大写或都转化为小写 - Character.toLowerCase(char ch)； 碰面的讨论： &lt;= or &lt; &lt;=：i, j 相遇的时候先不跳出； &lt;：不允许 i, j 相遇； 但是中间的一个元素对是不是回文不影响，所以都可以。 Code Afterthoughttime complexity: O(n) space complexity: O(1)"},{"title":"剑指II-017. 含有所有字符的最短字符串","date":"2022-10-21T06:17:34.000Z","url":"/2022/10/21/jzii017/","tags":[["HashTable","/tags/HashTable/"],["Sliding window","/tags/Sliding-window/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定两个字符串 s 和 t 。返回 s 中包含 t 的所有字符的最短子字符串。如果 s 中不存在符合条件的子字符串，则返回空字符串 “” 。 如果 s 中存在多个符合条件的子字符串，返回任意一个。hard src： SolutionsSolution 1 (sliding window + hashtable)Thoughts 中包含 t 的所有字符的最短子字符串，返回子字符串。 s，t 均由英文字母组成。 基本思路是：记下 t 的所有字符，以此为根据，在 s 上进行 sliding window 操作。 实现时要注意： 记下 t 的所有字符； 具体如何 sliding window，也就是 left 何时走，right 何时走； 符合条件的 window 如何选最短； 使用 hashtable 来记录记录字符，每个种类的出现次数。 具体如何 sliding window，示意图如下。 如果一个 window 中刚好把 t 中的所有字符都找到了，那么，这就是符合条件的 window。 我们通过在 s 中每找到一个吻合的字符，计数器 count 就 +1，之后看计数器是不是等于 t 的长度。 但是如果不是在 s 的最后找全，因为计数器一旦到这个数就不变了，之后的都会被认为是符合的，举例 s 为 abb，t 为 a，那么因为找得到 a，count 变为 1，之后的 b 因为在 t 中找不到，所以计数器不变，就还是 1，这时即使子串长度变长了，还是可以通过计数器的判断。所以，我们不能仅仅通过这点来得到结果，应该在每一次通过计数器判断后，记录当前长度，在此基础上选更短的。 不可以在循环开始char curR = s.charAt(r)，之后就用 curR, curL代替 s.charAt(r), s.charAt(r)，因为循环内只是保持 right 的不动，left 是可能会移动的，如果一开始就把 curL 固定下来了，那么就可能失真。 Code Afterthoughttime complexity: O(n) space complexity: O(n)"},{"title":"剑指II-016. 不含重复字符的最长子字符串","date":"2022-10-21T02:22:01.000Z","url":"/2022/10/21/jzii016/","tags":[["HashTable","/tags/HashTable/"],["Sliding window","/tags/Sliding-window/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定一个字符串 s ，请你找出其中不含有重复字符的 最长连续子字符串 的长度。medium src： SolutionsSolution 1 (sliding window + hashtable)Thought题目给出 s，求它不含重复字符的最长连续子字符串的长度。 去重：使用 hashtable 来完整记录每种字符最新的出现下标，key 为字符，value 为最新出现的下标。 sliding window 的思路见下图： 在 sliding window 时，right 读到已有的值，那么这时就需要把 left 放到新的位置，这时两种情况： left 有必要移动：重复是当前 window 里的； left 没必要移动：重复是 window 左边的，这时移动的话，窗口就不单向了（下图）； Code Afterthoughttime complexity: O(n) space complexity: O(n)"},{"title":"剑指II-015. 字符串中的所有变位词","date":"2022-10-11T14:40:43.000Z","url":"/2022/10/11/jzii015/","tags":[["Sliding window","/tags/Sliding-window/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定两个字符串 s 和 p，找到 s 中所有 p 的 变位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。 变位词 指字母相同，但排列不同的字符串。 src： SolutionsSolution 1 (sliding window)Thought我们找到 p 的某一种排列在 s 中的位置。 套用 剑指II_014 的思路（下图），不过这次要记录符合要求的 window 的起点。 ⚠️注意: 本题要求子串的起始下标，所以第一个或者最后一个需要在循环外面讨论： 可以在第一把位放好之后就讨论； 也可以在跑到最后一把的时候，出循环来讨论； Code Afterthoughttime complexity: O(n) space complexity: O(1)"},{"title":"剑指II-014. 字符串中的变位词","date":"2022-10-11T14:35:13.000Z","url":"/2022/10/11/jzii014/","tags":[["Sliding window","/tags/Sliding-window/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的某个变位词。 换句话说，第一个字符串的排列之一是第二个字符串的 子串 。 src： SolutionsSolution 1 (sliding window)Thought题目要我们判断 s1 的某一种排列是否是 s2 的子串。 因为本题是子串，子串由连续不间断的一串元素组成，就想到用 sliding window 来做。 实现的时候要注意： s1 的某一种排列； 在 s2 中寻找 s1 的某一种排列； s1 的某一种排列，不必真的写出 s1 的全排列，解释如下： 先提问：假设我们有 4 个士兵可派遣，其中有 2 个斧兵，2 个长枪兵，有多少种布阵方法？ 我们对具体的布阵不关心，无论存在几种方法，都要符合 2 个斧兵，2 个长枪兵。推到本题，s1 的所有元素就可以理解为小兵，有不同兵种，我们按兵种记下来，就可以应对各种情况。 数组的下标是兵种（a-z，可以通过通通减去 a，变为 int），下标对应的值是每个兵种的数量（int）。 在 s2 中寻找 s1 的某一种排列： 这就是对照尺（s1），我们凭这个一把一把地在地图上（s2）比较，直到找到对应的。 在 sliding window 时需要进行维护，示意图如下： 比较两数组是否相等 ：Arrays.equals(int[] a, int[] a2)，两数组相等则返回 true； 因为题目没有说 s1 长度一定 &lt;&#x3D; s2 长度，所以这方面的边界情况可以拎出来讨论一下； Code Afterthoughttime complexity: O(n) space complexity: O(n)"},{"title":"剑指II-013. 二维子矩阵的和","date":"2022-10-11T14:24:05.000Z","url":"/2022/10/11/jzii013/","tags":[["Matrix","/tags/Matrix/"],["Prefix Sum","/tags/Prefix-Sum/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定一个二维矩阵 matrix，以下类型的多个请求： 计算其子矩形范围内元素的总和，该子矩阵的左上角为 (row1, col1) ，右下角为 (row2, col2) 。 实现 NumMatrix 类： NumMatrix(int[][] matrix) 给定整数矩阵 matrix 进行初始化 int sumRegion(int row1, int col1, int row2, int col2) 返回左上角 (row1, col1) 、右下角 (row2, col2) 的子矩阵的元素总和。 src： SolutionsSolution 1 (matrix prefix sum)Thought题目要我们先初始化 matrix，之后写一个方法来实现计算区域面积内的元素和。 实现的时候要注意： prefix sum 的偏移； 如何求区域内的元素和； prefix sum 会有偏移，以普通的一维数组为例，preSum[1] 包含 nums[0]，preSum[0] 不含 nums 中的任意元素，也就是说 preSum 的 index 与 nums 的 index 有偏移。 求区域内的元素和，可以先从基本的某一点的 prefix sum 开始理解，示意图如下： 之后推广到给区域的左上角和右下角，求该区域元素和，示意图如下： 上图框起来的，不懂就参考：如何求二维的前缀和，以及用前缀和求子矩形的面积 Code Afterthoughttime complexity: O(n * m) space complexity: O(n * m)"},{"title":"剑指II-012. 左右两边子数组的和相等","date":"2022-10-11T14:12:04.000Z","url":"/2022/10/11/jzii012/","tags":[["Math","/tags/Math/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"题干给你一个整数数组 nums ，请计算数组的 中心下标 。 src： SolutionsSolution 1 (找规律)Thought题目要求满足左侧元素和等于右侧元素和的 pivot index ，可以发现如下规律（下图） 。 Code Afterthoughttime complexity: O(n)，n &#x3D; nums.length space complexity: O(n)； "},{"title":"剑指II-011. 0 和 1 个数相同的子数组","date":"2022-10-11T13:42:07.000Z","url":"/2022/10/11/jzii011/","tags":[["HashTable","/tags/HashTable/"],["Prefix Sum","/tags/Prefix-Sum/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定一个二进制数组 nums , 找到含有相同数量的 0 和 1 的最长连续子数组，并返回该子数组的长度。 src： SolutionsSolution 1 (prefix sum + hashtable)Thought0, 1 数量相等的最长连续子数组，返回该子数组的长度。 nums 中只有 0 或 1，考虑用替换来把数量相等转化为求和。如果把 0 换成 -1，如此，某一段的元素和为 0，就意味着这段的 0, 1 数量相等。 实现的时候要注意： prefix sum 的偏移； sub array 的长度读取； prefix sum 会有偏移，preSum[1] 包含 nums[0]，preSum[0] 不含 nums 中的任意元素，也就是说 preSum 的 index 与 nums 的 index 有偏移。 hashtable 的 key 为当前 preSum 的值，继续遍历 preSum，如果读到相同的 key，就意味着这段的 0, 1 数量相等。那么，这段 sub array 的长度可以通过在首次 default 的时候，存入当时 preSum 的 index，之后读到对应 key 时，hashtable 的 value 相减来得到（下图）。 根据题意，nums.length &gt;&#x3D; 1，nums 又只有 0,1，那么 sub array 长度必然 &gt;&#x3D; 2，所以我们让循环从 2 开始，来节约一点时间。 Code Afterthoughttime complexity: O(n)，n &#x3D; nums.length space complexity: O(n)； Solution 2 (prefix sum + hashtable -&gt; regular)Thought使用数组模拟 hashtable，来节约空间。 hashtable 起到的作用是： 检查某一 preSum[i] （hashtable 的 key）是否出现过； 记录这一 preSum[i] 所对应的首次下标； 只要 hash 数组留出 nums.length 的长度，就可以用来记录首次出现下标。 hash 的 nums.length + 1 长度留给 preSum，最坏情况 nums 全是 1，那么 hash 的 nums.length + 1 部分将被填满。 Code Afterthoughttime complexity: O(n)，n &#x3D; nums.length space complexity: O(n)； Solution 3 (hashtable)Thought回到和的问题本身。 本质上和 solution 1，solution 2 一样，都是通过对 nums 元素的替换，把求 01 数量相等转化为求和。 hashtable 的第一例需要提前初始化，(0, -1) 意为 preSum 等于 0，首次出现的下标为 -1，也就是什么元素都没有。 ⚠️注意： 这里不可以用 getOrDefault(key, default value)。 初次：写入下标； 不是初次：读到对应的 value，来计算 sub array 的长度； 可见，如果不是初次，那么读值之后还有一系列操作，来得到 sub array 的长度，所以需要分开讨论。 Code Afterthoughttime complexity: O(n)，n &#x3D; nums.length space complexity: O(n)；"},{"title":"剑指 Offer II 010. 和为 k 的子数组","date":"2022-06-09T13:20:20.000Z","url":"/2022/06/09/jzii010/","tags":[["HashTable","/tags/HashTable/"],["Prefix Sum","/tags/Prefix-Sum/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定一个整数数组和一个整数 k ，请找到该数组中和为 k 的连续子数组的个数。 src： 例子： 注意 1 &lt;&#x3D; nums.length &lt;&#x3D; 2 * 104 -1000 &lt;= nums[i] &lt;= 1000 -107 &lt;&#x3D; k &lt;&#x3D; 107 SolutionsSolution 1 (prefix sum)题目给了 nums 和 k，要我们找到 nums 中满足和为 k 的连续子数组，要求返回子数组的个数； 因为本题 nums 是一个整数数组，可能有负数，那么 sliding window 的时候，right 前进有可能会使 sum 变小，就无法定向调节 sum 了，所以 sliding window 不可以； Work &amp; Thought 题目中有求和和连续子数组，考虑用 prefix sum 切入，preSum 数组存储 prefix sum，比如 preSum[i] 储存 nums[i] 之前的所有元素的和； preSum[i] 可以包括 nums[i] 也可以不包括，区别在于 preSum 式子的写法，下面的例子就是不包括 nums[i]； 这种要在 preSum 最后追加一个，记录 nums[i] 的 index 从 0 到 nums.length - 1 元素的和； 还要注意到 preSum 数组比 nums 数组占用的长度大1，因为有追加的一个； preSum[i] = preSum[i-1] + nums[i-1] 关于 sum 的数据类型，根据题意 nums[i] &lt;&#x3D; 103，nums.length &lt;&#x3D; 2 * 104，所以 sum &lt;&#x3D; 2 * 107 也必然小于 Integer.MAX_VALUE； 之后读 preSum 数组的时候要注意有偏移，index 从 1 开始，也就是 preSum[1] &#x3D; nums[0]，preSum[len] &#x3D; nums[0] + … + nums[len - 1]，向右偏移了1，所以如果要完整地从头开始，就是preSum[j] - preSum[i - 1] ，而不是 preSum[j] - preSum[i] （下图）； Code Afterthought易错点: preSum 数组比 nums 数组的长度大 1； preSum 会有偏移； time complexity: O(n2)； space complexity: O(n)； 如果把 preSum 存到 dic 里面，那么通过一次遍历，就可以得到符合的子数组。 Solution 2 (prefix sum, hashtable)Work &amp; Thought建立一个dic，key 和 value 如下表： key value preSum times 在每次查到吻合的preSum时，result加 1 。（ result 用来储存待返回的结果） 那么，怎么样的 preSum 是符合要求的，有以下两点： preSum &#x3D;&#x3D; k，题目说的和为k preSum &#x3D;&#x3D; k + x（x 曾经存到dic里面），意思是这一段包含和为k的部分（下图） ![II_010_preSum_03.jpeg]() Code Afterthought易错点: 针对 code 中的 why 进行解释，这是为哈希表还是空表的时候，比如nums[0]就满足 k，可以不漏值而写；也可以通过在前面放一个哈希表的起始值map.put(0, 1)，相当于 preSum &#x3D; 0，times &#x3D; 1，这样就可以在这个初始值的基础上计算 preSum； 漏值情况举例：nums = [3, ...], k = 3 和 nums = [1, 1, 1,...], k = 3； time complexity: O(n)； space complexity: O(n)；"},{"title":"剑指 Offer II 009. 乘积小于 K 的子数组","date":"2022-06-09T13:20:17.000Z","url":"/2022/06/09/jzii009/","tags":[["Two Pointers","/tags/Two-Pointers/"],["Two Pointers_Sliding Window","/tags/Two-Pointers-Sliding-Window/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定一个正整数数组 nums和整数 k ，请找出该数组内乘积小于 k 的连续的子数组的个数。 src： 例子： 注意 1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 104 1 &lt;= nums[i] &lt;= 1000 0 &lt;&#x3D; k &lt;&#x3D; 106 SolutionsSolution 1 (sliding window)题目给了 nums 和 k，要我们找到 nums 中满足乘积 小于k 的连续子数组，要求返回子数组的个数； 如果是求 小于k 中最长的连续子数组，并返回长度，就很适合 sliding window； Work &amp; Thought本题要返回子数组的个数，所以需要建立 left，right 和个数result的关系，发现了每次 right 前进， result 都可以增加 right - left + 1； 关于 product 的数据类型，根据题意 k &lt; 106，nums[i] &lt;&#x3D; 103，所以 product &lt;&#x3D; 109 也必然小于 Integer.MAX_VALUE； 子数组个数与 right-left+1 的关联图示： Code Afterthought易错点: 如果连续子数组[i,...,j]的 product &lt; k，那么[i,...,j]内部的所有连续子数组都符合条件，因为nums是正整数数组； time complexity: O(n)； space complexity: O(1)；"},{"title":"剑指 Offer II 008. 和大于等于 target 的最短子数组","date":"2022-06-09T12:59:27.000Z","url":"/2022/06/09/jzii008/","tags":[["Two Pointers","/tags/Two-Pointers/"],["Two Pointers_Sliding Window","/tags/Two-Pointers-Sliding-Window/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 src： 例子： 注意 1 &lt;&#x3D; target &lt;&#x3D; 109 1 &lt;&#x3D; nums.length &lt;&#x3D; 105 1 &lt;&#x3D; nums[i] &lt;&#x3D; 105 进阶：如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。 SolutionsSolution 1 (sliding window)题目给了 nums 和 target，要我们找到 nums 中满足和&gt;&#x3D;target的连续子数组，要求返回最短的长度。 Work &amp; Thought这道是经典的 sliding window 题目。 两个指针 i，j 初始在同一起点，j 先走，直到满足题目的条件，也就是和&gt;&#x3D;target，此时轮到 i 前进了，开始找最短连续子数组，直到不满足条件。i，j 就这样前进，j 在前面领路，i 在后收尾。（例子如下图） Code Afterthought易错点: 求长度：r - l + 1 time complexity: O(n)； space complexity: O(1)；"},{"title":"剑指 Offer II 007. 数组中和为 0 的三个数","date":"2022-06-09T12:41:05.000Z","url":"/2022/06/09/jzii007/","tags":[["Two Pointers","/tags/Two-Pointers/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a ，b ，c ，使得 a + b + c &#x3D; 0 ？请找出所有和为 0 且 不重复 的三元组。 src： 例子： 注意 0 &lt;= nums.length &lt;= 3000 -105 &lt;&#x3D; nums[i] &lt;&#x3D; 105 SolutionsSolution 1 (brute force，Two Pointers)题目给了一个包含若干整数的数组，要求找到三个元素的和等于0，返回所有三元组。 返回的三元组不重复。 Work &amp; Thought把找三个元素转化为找两个元素，那就不难了。 如果这个数组是有序（升序）的数组，固定一个值，就找剩下的两个元素，和 2sum 的原理差不多（2sum 见图示）； 因为可能不止一个答案，所以在找到一个吻合的之后，指针不能停住了，要继续移动； 注意去重，可以用和上一个指针的 val 比较，如果一致，就跳过； 三个元素中，固定下来的值移动时要去重； 在找到一个吻合的之后，指针继续移动时也要去重； Code Afterthought易错点: 将指定数组升序排序，Arrays.sort()； 把若干元素变为 List 形式，Arrays.asList(T… a)，举例res.add(Arrays.asList(nums[i], nums[l], nums[r])); sum 与 target 的关系 &gt;、 &lt;、 == 连在一起成为一个整体，所以用 if.. else if.. else… 连起来，不要用三个 if； time complexity: O(n2)； space complexity: O(1)；"},{"title":"剑指 Offer II 006. 排序数组中两个数字之和","date":"2022-06-09T11:06:55.000Z","url":"/2022/06/09/jzii006/","tags":[["Two Pointers","/tags/Two-Pointers/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定一个已按照 升序排列 的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。 函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 0 开始计数 ，所以答案数组应当满足 0 &lt;&#x3D; answer[0] &lt; answer[1] &lt; numbers.length 。 假设数组中存在且只存在一对符合条件的数字，同时一个数字不能使用两次。 src： 例子： 注意 2 &lt;&#x3D; numbers.length &lt;&#x3D; 3 * 104 -1000 &lt;&#x3D; numbers[i] &lt;&#x3D; 1000 numbers 按 递增顺序 排列 -1000 &lt;&#x3D; target &lt;&#x3D; 1000 仅存在一个有效答案 SolutionsSolution 1 (brute force，Two Pointers)题目给了一个包含若干数字的数组，要求找到两个数字的和等于target，返回这两个数字的下标。 数组升序且答案唯一。 Work &amp; Thought思路是双指针分别从头尾走，利用数组的升序来调整指针位置，直到找到这两个数字。 （如下图） Code Afterthought易错点: 直接向数组中加入元素，数组的静态初始化，举例：new int[]&#123;left, right&#125;； sum 与 target 的关系 &gt;、 &lt;、 == 连在一起成为一个整体，所以用 if.. else if.. else… 连起来，不要用三个 if； time complexity: O(n)，遍历一遍 nums； space complexity: O(1)；"},{"title":"剑指 Offer II 005. 单词长度的最大乘积","date":"2022-06-09T10:13:26.000Z","url":"/2022/06/09/jzii005/","tags":[["Bitwise","/tags/Bitwise/"],["Bitwise_Bit Shifting","/tags/Bitwise-Bit-Shifting/"],["Matrix","/tags/Matrix/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定一个字符串数组 words，请计算当两个字符串 words[i] 和 words[j] 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。 src： 例子： 注意 2 &lt;= words.length &lt;= 1000 1 &lt;= words[i].length &lt;= 1000 words[i] 仅包含小写字母 SolutionsSolution 1 (brute force，matrix)题目要求两个不重复的单词长度乘积最大，并返回该乘积。根据题意，单词 words[i] 仅包含小写字母，我们可以创造一个 matrix[words.length][26] 来记录，之后读表选取无相同字母的，并对其求积。 Work &amp; Thought（如下图） Code Afterthought易错点: 把字符串转变为一个新的 char 数组，toCharArray() for 循环可以缺少初始化语句、循环条件和每次循环更新语句 例如： for(; k &lt; 26; k++)&#123; time complexity: O(m * n2)，假设 m 为每个单词的平均长度，n 为 words 包含的单词数量； space complexity: O(n)； Solution 2 (bitwise)Solution 1 是把单词数组中的每个单词变成一个 entry，单个单词中的字母出现与否也占用一个维度，空间上可以再进行压缩。 Work &amp; Thought 如果将 26 个英文单词和 32 位的 int 联系起来，让单个单词中的字母占用一个 bit 位，0&#x2F;1 表示出现与否，就可以降维成一维 int 数组。 Code Afterthought易错点: binary 中放 1 用|，因为 OR 任意为 1 是 1，举例 mask[i] |= 1 &lt;&lt; 2，如果 mask[i] 原本是 001，就变为 101； 运算符优先级，== 优先于 &amp;，所以 (mask[i] &amp; mask[j]) == 0 的括号是必要的； time complexity: O(mn + n2)，假设 m 为每个单词的平均长度，n 为 words 包含的单词数量； space complexity: O(n)； 本方法与方法 1 思路差不多，就是需要熟悉位运算的一些操作。 Reference 文章图片来源 - hualuoyueque 链接： "},{"title":"剑指 Offer II 004. 只出现一次的数字","date":"2022-06-07T06:37:32.000Z","url":"/2022/06/07/jzii004/","tags":[["Bitwise","/tags/Bitwise/"],["Bitwise_Bit Shifting","/tags/Bitwise-Bit-Shifting/"],["Set","/tags/Set/"],["HashTable","/tags/HashTable/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。 src： 例子： 注意 1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 104 -231&lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1 nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 进阶：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ SolutionsSolution 1 (数学方法，set)nums 除了目标元素只出现 1 次，剩余的每个元素都出现 3 次，那么可以利用 set 去重来做题。 Work &amp; ThoughtsumDistinct * 3 - sum &#x3D; target * 2； Code Afterthought易错点: 在计算 target 的值时，将会溢出 int 的边界，所以先放到 long 类型的变量里面； time complexity: O(n)，遍历 nums 数组； space complexity: O(n)，存放到 set 中占用的空间； Solution 2 (hashtable)nums 除了目标元素只出现 1 次，剩余的每个元素都出现 3 次，可以用 hashtable 来打表查表。 Work &amp; Thought用哈希表计数，先遍历数组放，后遍历哈希表查次数为1的key。 key value 数值 出现次数 Code Afterthought易错点: for each 的写法，关于遍历 hashmap（通过map.keySet()）； JDK 1.8 开始可以用 getOrDefault(key, default value)，在要赋默认值的场景下很好用； time complexity: O(n)，遍历 nums 数组； space complexity: O(n)，存放到 hashmap 中占用的空间； Solution 3 (bit wise, bit shifting)不占用额外的空间。 二进制的数，比如 1001，出现 3 次，若记录 1 出现的次数，为 3003，之后对其进行 mod 3 操作，就没有余数。 Work &amp; Thought根据题目，-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231- 1，我们可以创建一个 32 位长度的数组 cnt[]，用来记录所有数值的每一位共出现了多少次 1，之后对 cnt[] 数组的每一位进行 mod 3 操作，就可以得到只出现 1 次的值。 Code Afterthought 运算符的优先级 &gt;&gt; ， &amp; &gt;&gt; 优先于 &amp; ，所以(cur &gt;&gt; i) &amp; 1不加括号也对 % ，&amp; % 优先于 &amp;，也就是乘除优先于逻辑 &lt;&lt; ， += &lt;&lt; 优先于 += ，也就是位优先于赋值，所以ans += (1 &lt;&lt; i)不加括号也对 数每一位出现1的次数，可用移位cur &gt;&gt; i == 1 来实现； time complexity: O(n)，遍历 nums 数组； space complexity: O(1)，常数的空间申请； Solution 4 (bit wise, bit shifting optimazed)Work &amp; Thought根据题意，-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231- 1，其实不用创建数组 cnt[]，一个 int 变量就可以，之后赋给返回结果 ans 即可。 int 是 32 位的，占用字节数 8 bit &#x3D; 4 byte，-231 &lt;&#x3D; cnt &lt;&#x3D; 231 - 1 Code Afterthoughttime complexity: O(n)，遍历 nums 数组； space complexity: O(1)，常数的空间申请； Reference 文章图片来源 - qingfengpython 链接： "},{"title":"剑指 Offer II 003. 前 n 个数字二进制中 1 的个数","date":"2022-06-06T13:42:09.000Z","url":"/2022/06/06/jzii003/","tags":[["Bitwise","/tags/Bitwise/"],["Bitwise_Bit Shifting","/tags/Bitwise-Bit-Shifting/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定一个非负整数 n ，请计算 0 到 n 之间的每个数字的二进制表示中 1 的个数，并输出一个数组。 src： 例子： 注意 0 &lt;= n &lt;= 105 进阶: 给出时间复杂度为 O(n*sizeof(integer)) 的解答非常容易。但你可以在线性时间 O(n) 内用一趟扫描做到吗？ 要求算法的空间复杂度为 O(n) 。 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount ）来执行此操作。 SolutionsSolution 1 (bit wise)i &amp; (i - 1) 可以消去最低位的 1 ，我们可以使用这种方法来计数。 Code Afterthought易错点: 运算符的优先级 &amp; and - - 优先于 &amp; ，所以这里i &amp; (i-1)可以没有括号； 数组的动态初始化，int[] c = new int[3]； time complexity: O(kn)， 假设计数时候的整数有k位； space complexity: O(1)； Solution 2 (iterate，bit wise optimazed)solution 1 是根据 i &amp; (i - 1) 可以消去最低位的 1 来计数，但需要对每一个数字（从 0-n）进行位数中的计数，是很浪费时间的。 Work &amp; Thought可以看出 i 和i &amp; (i - 1)的关联，即i 比i &amp; (i-1)多了一个最右边的1，举例，1110 比 1100 多一个1，也就是 14 比 12 多一个1。利用这点，就可以以小推大。 Code Afterthought易错点: 运算符的优先级 &amp; and - - 优先于 &amp; ，所以这里i &amp; (i-1)可以没有括号； 数组的动态初始化，int[] c = new int[3]； time complexity: O(n)； space complexity: O(1)； 迭代的思想。 Solution 3 (iterate，bit shifting，bit wise optimazed)如果要以小推大，就要建立起关联，我们可以发现，i 与 i &gt;&gt; 1 存在联系。 Work &amp; Thoughti 与 i &gt;&gt; 1存在联系： 如果 i 最低位为 0，即 i 为偶数，那么 i 与 i &gt;&gt; 1 二进制 1 的个数相同； 如果 i 最低位为 1，即 i 为奇数，那么 i 比 i &gt;&gt; 1 多一个1； 奇偶的判定：x &amp; 1，x 为偶数，结果为 0；x 为奇数，结果为 1； 那么，就可以列出式子：arr[i] = arr[i &gt;&gt; 1] + (i &amp; 1)； Code Afterthoughttime complexity: O(n)； space complexity: O(1)； 迭代的思想。 "},{"title":"剑指 Offer II 002. 二进制加法","date":"2022-06-06T07:06:05.000Z","url":"/2022/06/06/jzii002/","tags":[["Simulation","/tags/Simulation/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定两个 01 字符串 a 和 b ，请计算它们的和，并以二进制字符串的形式输出。 输入为 非空 字符串且只包含数字 1 和 0。 src： 例子： 注意 每个字符串仅由字符 &#39;0&#39; 或 &#39;1&#39; 组成。 1 &lt;= a.length, b.length &lt;= 10^4 字符串如果不是 &quot;0&quot; ，就都不含前导零。 SolutionsSolution 1 (brute force, simulation)题目要求实现加法，第一个想法是把传入参数直接加，但是是二进制，所以想到用模拟加法来做这道题（下图）。 Work &amp; Thought从右到左一位位地进行计算，把每一位的计算结果 append 到返回的结果 String（先放在可变字符串 StringBuilder），最后 reverse，也转成题目要求的 String。 指针 i，j 来指正在计算的位，读到的数据分别存到 digitA，digitB，输出结果存到 StringBuilder（可变，不同步）； 在逆序、返回结果前，记得把最后的 carry 加上； Code Afterthought易错点: i--，先引用后减去，即先让i所在的表达式中使用i的当前值，再让i减 1； 进位之后，记得 sum 要减去对应的进位，不然 sum 加到 result 上，后面就乱了； char 的 0、1 并不等同于 int 的 0、1，如果直接将 char 值 0 硬转为 int，得到的 int 值是 48，本题显然不是要 48，所以要减去 ‘0’； time complexity: O(max(M, N) )， 其中 M，N 为 a, b 数字长度，按位遍历一遍数字（以较长的数字为准）； space complexity: O(1)； 想到用模拟来做之后，思路清晰，这道题目还是很好写的，没什么难的。 "},{"title":"剑指 Offer II 001. 整数除法","date":"2022-05-31T12:46:28.000Z","url":"/2022/05/31/jzii001/","tags":[["Bitwise","/tags/Bitwise/"],["Simulation","/tags/Simulation/"],["Bitwise_Bit Shifting","/tags/Bitwise-Bit-Shifting/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定两个整数 a 和 b ，求它们的除法的商 a/b ，要求不得使用乘号 &#39;*&#39;、除号 &#39;/&#39; 以及求余符号 &#39;%&#39; 。 src： 例子： 注意 整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2； 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231−1]。本题中，如果除法结果溢出，则返回 231 − 1； -231 &lt;&#x3D; a, b &lt;&#x3D; 231 - 1； b !&#x3D; 0； SolutionsSolution 1 (brute force) 不进行模拟，也不进行位运算。直观。 题目要求a除以b的商，且截去小数部分，可以理解为 a 等价于 n * b + c（c &lt; b），用减法来实现乘法。 思想很简单，但是实现的时候要注意： 越界问题，int 类型的范围； 返回结果的正负号，计算的环境（正 or 负）； Work &amp; Thought 越界的讨论，本题是整数除法（c must &lt;&#x3D; a），所以溢出的情况只有一个，就是 −231 &#x2F; -1，它的结果 231 越界了，根据题目，需要特殊处理返回231 − 1； 还有一种情况，如果是在正数的计算环境中，a&#x3D;−231，a在转变成正数的时候，变成231，溢出了。所以，要么都变负数，要么特殊情况拎出来讨论。 结果的正负号，可以先记好，只有在它俩异号的时候商是负号，就是它俩一个负数 or 一个正数，用一个变量记下，之后统一计算的环境，进行计算； Code Afterthoughttime complexity: O( ) 难以具体地给出；space complexity: O(1)； 计算量太大，最坏情况如果a是 −231，b是 1，计算出商，需要算很多次。 在超时的边缘试探，leetcode 很难跑过。 特点是思路直观，因为 Java 语言的特点，需要考虑 int 越界这个因素，在结果输出和计算的时候都要考虑到这一点，是本题的难点。 Solution 2 (bit wise &amp; simulation)Work &amp; Thought 对于 int 越界问题，和 Solution 1 差不多的解法，先筛掉特殊情况，之后使用负数的计算环境； 如果要用正数计算环境，需要把传入的参数 a，b 强制转型为 long； 返回结果的正负号问题： 铺垫： 位运算的异或（不同是1）和与（同时为1是1），Integer.MIN_VALUE是负数，最高位为1； Integer.MIN_VALUE -2147483648 1-0000 0000 0000 0000 0000 0000 0000 000 a ^ b 解释：若a，b同号，0xxxx，若异号，1xxxx，这时和 Integer.MIN_VALUE 进行与运算，除了最高位，其它位均清0，得到结果 0（ab同号） or 1（ab异号）； 也可以这样：a ^ b &gt;&#x3D; 0，若大于0，就是异号，反之，就是同号，因为最高位是符号位； 相比于 Solution 1 的 flag，这个解法能体现位运算的知识储备。 simulation 部分：模拟除法的手写算式（二进制），本质还是减法，但是里面的一层用二进制，这样就可以用移位运算，省到log级别的时间复杂度。 Code Afterthoughttime complexity: O( logn) 难以具体地给出；space complexity: O(1)； 针对 int 越界的问题，用了 long，一些情况下可能会限制使用 long。 跑很快。 特点是移位运算，里面的一层循环要理清，算是难点。 商的正负号判断，相比于对 a，b 进行大于 0 小于 0 来说亮眼了，但是普通方法也是完全可以的。 Amended version of Solution2题目说我们的环境只能存储 32 位有符号整数，所以理论上，使用 long 是不被允许的。 位运算的环境改成 负数 就可以。 Code"},{"title":"Git 向导","date":"2021-05-04T21:40:14.000Z","url":"/2021/05/05/git-guide/","categories":[["Git","/categories/Git/"]],"content":"Git 是什么？Git 是一个分布式版本控制系统（Distributed Version Control System），客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。 四个特点： 直接记录快照，而非差异比较； 近乎所有操作都是本地执行； Git 保证完整性； Git 一般只添加数据； Git 的工作流程 （Git - Workflow 来源：阮一峰的网络日志） 专业名词基本的 Git 工作流程： 在工作区（Workspace）中修改文件； 将更改选择性暂存至暂存区（Staging area&#x2F; Index）； 提交暂存区的内容到本地仓库（Repository）； Git 的三种状态，文件可能处于其一，假设这个文件是README.md，那么它为： modified：修改了文件，但修改仅在工作区； staged：将工作区已修改的文件放到了暂存区； committed：文件已经安全地保存到本地仓库。 配置 设置提交代码时的用户信息： 检查设定： 配置文件的路径： 本地仓库配置对应的配置文件路径 [–local] ： 用户全局配置对应的配置文件路径 [–global] ： 系统配置对应的配置文件路径[–system]： 新建代码库From existing data From existing repository注意：Git 克隆的是远程 Git 仓库的几乎所有数据，不仅仅是最新的版本。 本地变动 – git status列出哪些文件已被暂存、未被暂存、未被跟踪，即查看工作目录下的文件处于什么状态： 添加指定文件到暂存区，即将该文件放到暂存区（new file）： 也可以用上面的这条指令来暂存已被跟踪文件的最新修改（modified）； 如果对暂存后的文件再次进行修改，之后查询文件状态，那么这时，这个文件将会同时出现在 staging area 和 workspace，因为最新的修改还在工作区，没有暂存，而之前 git add 的版本被暂存了，如果这时提交，那么本地仓库的版本将会是最后一次 git add 的版本，不包含 workspace 中最新的修改。 本地变动 – git diff列出追踪但尚未暂存的文件更新了哪些部分，即工作区和暂存区的差异： 注意：git diff 不能显示自从上次提交的所有变化，它只能显示尚未暂存的变化。如果已经把所有修改的内容都暂存了，那么 git diff 不会有任何反馈。 列出已经暂存，但是没有提交到本地仓库的变化，即暂存区和上一个 commit 的差异： 列出工作区和上一个 commit 的差异（当前分支最新commit）： 列出两次 commit 之间的差异： 本地变动 – git add添加当前目录的所有文件到暂存区： 注意：如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。 对于同一个文件的多处变化，可以实现分次提交： 可以更好地利用 git commit 的注释功能，使仓库的版本颗粒度更高，可读性更好。 参考： stack overflow：Commit only part of a file in Git Git docs：git-add manpage 本地变动 – git rm删除工作区文件，并且将这次删除放入暂存区： 停止追踪指定文件，但该文件会保留在工作区： 比如删除添加.gitignore文件前错误提交的文件。 本地变动 – git mv移动文件，并将这个移动放入暂存区（也可以理解为文件改名）： 参考： Git docs：git-mv manpage 提交到本地仓库 – git commit提交暂存区到本地仓库： 也可以指定暂存区的文件提交到本地仓库，只要在 commit 后面指定 file。 跳过暂存区，直接将工作区自上次 commit 之后的变化，提交到本地仓库： 使用一次新的 commit，替代上一次提交： 重做上一次 commit，并包括指定文件的新变化： 参考： Git docs：git-commit manpage 提交到本地仓库 – git log列出当前分支的版本历史： 仅列出包含指定文件修改的 commit： 限制 log 的显示数量： 列出所有提交，每行显示一条 commit（仅显示提交的 hash 和 message）： 按提交者名字搜索并显示 commit： 按指定内容搜索并显示 commit： 显示图形化的 branch 信息： 参考： Git docs：git-log manpage 提交到本地仓库 – git reflog列出本地仓库的所有 commit： 提交到本地仓库 – git blame列出指定文件是什么人在什么时间修改过： 也可以具体查文档内部某一部分是谁修改： 参考： Git docs：git-blame manpage 远程仓库 – 拉取到本地拉取远程仓库的所有变动到本地，但不合并： 拉取远程仓库特定分支的更新到本地，不合并： 拉取远程仓库的所有变动到本地，之后自动与 HEAD 版本合并： 拉取远程仓库的所有变动到本地，并以 rebase 模式并入本地仓库： 列出当前配置的所有远程端： 如果远程仓库不止一个，那么就会全部列出，比如和多个协作者合作的，这样可以非常方便地拉取其他用户的贡献，还拥有向他们推送的权限。 显示某个远程端的信息： 增加一个新的远程仓库，并指定简写： 远程仓库 – 推送到远程上传本地指定分支到远程仓库： 注意：只有当有推送到该远程仓库的权限，及之前没有人推送过时，该命令才有效。如果有他人先推送到上游，那么，此时的推送命令就会被拒绝，必须先抓取他们的工作并将其合并到本地仓库，才能推送。 参考： Git book：remote branches 分支 – git branch列出本地仓库的所有分支： 列出所有远程分支： 列出所有本地分支和远程分支： 新建一个分支，但依然停留在当前分支： 新建一个分支，并切换到该分支： 新建一个分支，指向指定 commit： 新建一个分支，与指定的远程分支建立追踪关系： 建立追踪关系，在现有分支与指定的远程分支之间： 切换到指定分支，并更新工作区： 切换到上一个分支： 合并指定分支到当前分支： 选择一个 commit，合并进当前分支： 删除分支： 若该分支的修改尚未合并，那么用 -D 参数来强制删除分支，注意，该操作会丢失未合并的修改。 删除远程分支： 分支 – git rebase基于 base 对当前分支进行 rebase。base 可以是 commit、分支名称、tag 或者相对于 HEAD 的 commit。 参考： Git docs：git-rebase manpage B站视频：git-rebase 图解 回滚 – git revert新建一个 commit，用来撤销指定 commit，并且应用到当前分支： 回滚 – git checkout恢复暂存区的指定文件到工作区： 恢复某个 commit 的指定文件到暂存区和工作区： 恢复暂存区的所有文件到工作区： 回滚 – git reset重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变，即撤销这个文件上次的 git add： 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变： 重置暂存区与工作区，与上一次 commit 保持一致： 重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致： 重置当前HEAD为指定 commit，但保持暂存区和工作区不变： 暂时将未提交的变化移除，稍后再移入： 回滚 – 具体场景场景1. 已经提交内容到本地仓库 如何回滚？ 场景2. 修改了还未提交到暂存区 怎么撤销？ 补充： 一种是该文件自修改后还没有放到暂存区，那么，现在撤销修改，就是回到和版本库一模一样的状态； 另一种是该文件添加到暂存区后，又做了修改，那么现在撤销修改，就是回到添加到暂存区后的状态； 场景3. 提交到暂存区，但还未提交到本地仓库 怎么办？ 把暂存区的修改撤销（unstage），重新放回工作区。 所以， git reset 既可以回退版本，也可以把暂存区的修改回退到工作区。 之后，丢弃工作区的修改即可。 标签列出所有标签： 给当前版本打标签： 给指定 commit 打标签： 删除本地标签： 删除远程标签： 提交指定标签： 提交所有标签： 新建一个分支，指向某个标签： Git 的 GUI 工具SourceTreeSourceTree 官网 IntelliJ IDEA 中的 GitIntelliJ IDEA 官方文档 相关链接 Pro Git book by Scott Chacon and Ben Straub. The book is available online for free at git-scm.com&#x2F;book. 常用 Git 命令清单：阮一峰的网络日志. Git Cheat Sheet: made by Hylke Bons. Git Cheat Sheet 中文版: translated by Gevin. "},{"title":"categories","date":"2022-04-06T16:36:46.000Z","url":"/categories/index.html","categories":[[" ",""]]},{"title":"search","date":"2022-04-06T16:11:22.000Z","url":"/search/index.html","categories":[[" ",""]]},{"title":"tags","date":"2022-04-06T16:35:46.000Z","url":"/tags/index.html","categories":[[" ",""]]}]