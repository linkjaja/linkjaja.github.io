[{"title":"剑指 Offer II 010. 和为 k 的子数组","date":"2022-06-09T13:20:20.000Z","url":"/2022/06/09/jzii010/","tags":[["HashTable","/tags/HashTable/"],["Prefix Sum","/tags/Prefix-Sum/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定一个整数数组和一个整数 k ，请找到该数组中和为 k 的连续子数组的个数。 src： 例子： 注意 1 &lt;&#x3D; nums.length &lt;&#x3D; 2 * 104 -1000 &lt;= nums[i] &lt;= 1000 -107 &lt;&#x3D; k &lt;&#x3D; 107 SolutionsSolution 1 (prefix sum)题目给了 nums 和 k，要我们找到 nums 中满足和为 k 的连续子数组，要求返回子数组的个数； 因为本题 nums 是一个整数数组，可能有负数，那么 sliding window 的时候，right 前进有可能会使 sum 变小，就无法定向调节 sum 了，所以 sliding window 不可以； Work &amp; Thought 题目中有求和和连续子数组，考虑用 prefix sum 切入，preSum 数组存储 prefix sum，比如 preSum[i] 储存 nums[i] 之前的所有元素的和； preSum[i] 可以包括 nums[i] 也可以不包括，区别在于 preSum 式子的写法，下面的例子就是不包括 nums[i]； 这种要在 preSum 最后追加一个，记录 nums[i] 的 index 从 0 到 nums.length - 1 元素的和； 还要注意到 preSum 数组比 nums 数组占用的长度大1，因为有追加的一个； preSum[i] = preSum[i-1] + nums[i-1] 关于 sum 的数据类型，根据题意 nums[i] &lt;&#x3D; 103，nums.length &lt;&#x3D; 2 * 104，所以 sum &lt;&#x3D; 2 * 107 也必然小于 Integer.MAX_VALUE； 之后读 preSum 数组的时候要注意有偏移，index 从 1 开始，也就是 preSum[1] &#x3D; nums[0]，preSum[len] &#x3D; nums[0] + … + nums[len - 1]，向右偏移了1，所以如果要完整地从头开始，就是preSum[j] - preSum[i - 1] ，而不是 preSum[j] - preSum[i] （下图）； Code Afterthought易错点: preSum 数组比 nums 数组的长度大 1； preSum 会有偏移； time complexity: O(n2)； space complexity: O(n)； 如果把 preSum 存到 dic 里面，那么通过一次遍历，就可以得到符合的子数组。 Solution 2 (prefix sum, hashtable)Work &amp; Thought建立一个dic，key 和 value 如下表： key value preSum times 在每次查到吻合的preSum时，result加 1 。（ result 用来储存待返回的结果） 那么，怎么样的 preSum 是符合要求的，有以下两点： preSum &#x3D;&#x3D; k，题目说的和为k preSum &#x3D;&#x3D; k + x（x 曾经存到dic里面），意思是这一段包含和为k的部分（下图） Code Afterthought易错点: 针对 code 中的 why 进行解释，这是为哈希表还是空表的时候，比如nums[0]就满足 k，可以不漏值而写；也可以通过在前面放一个哈希表的起始值map.put(0, 1)，相当于 preSum &#x3D; 0，times &#x3D; 1，这样就可以在这个初始值的基础上计算 preSum； 漏值情况举例：nums = [3, ...], k = 3 和 nums = [1, 1, 1,...], k = 3； time complexity: O(n)； space complexity: O(n)；"},{"title":"剑指 Offer II 009. 乘积小于 K 的子数组","date":"2022-06-09T13:20:17.000Z","url":"/2022/06/09/jzii009/","tags":[["Two Pointers","/tags/Two-Pointers/"],["Two Pointers_Sliding Window","/tags/Two-Pointers-Sliding-Window/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定一个正整数数组 nums和整数 k ，请找出该数组内乘积小于 k 的连续的子数组的个数。 src： 例子： 注意 1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 104 1 &lt;= nums[i] &lt;= 1000 0 &lt;&#x3D; k &lt;&#x3D; 106 SolutionsSolution 1 (sliding window)题目给了 nums 和 k，要我们找到 nums 中满足乘积 小于k 的连续子数组，要求返回子数组的个数； 如果是求 小于k 中最长的连续子数组，并返回长度，就很适合 sliding window； Work &amp; Thought本题要返回子数组的个数，所以需要建立 left，right 和个数result的关系，发现了每次 right 前进， result 都可以增加 right - left + 1； 关于 product 的数据类型，根据题意 k &lt; 106，nums[i] &lt;&#x3D; 103，所以 product &lt;&#x3D; 109 也必然小于 Integer.MAX_VALUE； 子数组个数与 right-left+1 的关联图示： Code Afterthought易错点: 如果连续子数组[i,...,j]的 product &lt; k，那么[i,...,j]内部的所有连续子数组都符合条件，因为nums是正整数数组； time complexity: O(n)； space complexity: O(1)；"},{"title":"剑指 Offer II 008. 和大于等于 target 的最短子数组","date":"2022-06-09T12:59:27.000Z","url":"/2022/06/09/jzii008/","tags":[["Two Pointers","/tags/Two-Pointers/"],["Two Pointers_Sliding Window","/tags/Two-Pointers-Sliding-Window/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 src： 例子： 注意 1 &lt;&#x3D; target &lt;&#x3D; 109 1 &lt;&#x3D; nums.length &lt;&#x3D; 105 1 &lt;&#x3D; nums[i] &lt;&#x3D; 105 进阶：如果你已经实现 O(n) 时间复杂度的解法, 请尝试设计一个 O(n log(n)) 时间复杂度的解法。 SolutionsSolution 1 (sliding window)题目给了 nums 和 target，要我们找到 nums 中满足和&gt;&#x3D;target的连续子数组，要求返回最短的长度。 Work &amp; Thought这道是经典的 sliding window 题目。 两个指针 i，j 初始在同一起点，j 先走，直到满足题目的条件，也就是和&gt;&#x3D;target，此时轮到 i 前进了，开始找最短连续子数组，直到不满足条件。i，j 就这样前进，j 在前面领路，i 在后收尾。（例子如下图） Code Afterthought易错点: 求长度：r - l + 1 time complexity: O(n)； space complexity: O(1)；"},{"title":"剑指 Offer II 007. 数组中和为 0 的三个数","date":"2022-06-09T12:41:05.000Z","url":"/2022/06/09/jzii007/","tags":[["Two Pointers","/tags/Two-Pointers/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a ，b ，c ，使得 a + b + c &#x3D; 0 ？请找出所有和为 0 且 不重复 的三元组。 src： 例子： 注意 0 &lt;= nums.length &lt;= 3000 -105 &lt;&#x3D; nums[i] &lt;&#x3D; 105 SolutionsSolution 1 (brute force，Two Pointers)题目给了一个包含若干整数的数组，要求找到三个元素的和等于0，返回所有三元组。 返回的三元组不重复。 Work &amp; Thought把找三个元素转化为找两个元素，那就不难了。 如果这个数组是有序（升序）的数组，固定一个值，就找剩下的两个元素，和 2sum 的原理差不多（2sum 见图示）； 因为可能不止一个答案，所以在找到一个吻合的之后，指针不能停住了，要继续移动； 注意去重，可以用和上一个指针的 val 比较，如果一致，就跳过； 三个元素中，固定下来的值移动时要去重； 在找到一个吻合的之后，指针继续移动时也要去重； Code Afterthought易错点: 将指定数组升序排序，Arrays.sort()； 把若干元素变为 List 形式，Arrays.asList(T… a)，举例res.add(Arrays.asList(nums[i], nums[l], nums[r])); sum 与 target 的关系 &gt;、 &lt;、 == 连在一起成为一个整体，所以用 if.. else if.. else… 连起来，不要用三个 if； time complexity: O(n2)； space complexity: O(1)；"},{"title":"剑指 Offer II 006. 排序数组中两个数字之和","date":"2022-06-09T11:06:55.000Z","url":"/2022/06/09/jzii006/","tags":[["Two Pointers","/tags/Two-Pointers/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定一个已按照 升序排列 的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。 函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 0 开始计数 ，所以答案数组应当满足 0 &lt;&#x3D; answer[0] &lt; answer[1] &lt; numbers.length 。 假设数组中存在且只存在一对符合条件的数字，同时一个数字不能使用两次。 src： 例子： 注意 2 &lt;&#x3D; numbers.length &lt;&#x3D; 3 * 104 -1000 &lt;&#x3D; numbers[i] &lt;&#x3D; 1000 numbers 按 递增顺序 排列 -1000 &lt;&#x3D; target &lt;&#x3D; 1000 仅存在一个有效答案 SolutionsSolution 1 (brute force，Two Pointers)题目给了一个包含若干数字的数组，要求找到两个数字的和等于target，返回这两个数字的下标。 数组升序且答案唯一。 Work &amp; Thought思路是双指针分别从头尾走，利用数组的升序来调整指针位置，直到找到这两个数字。 （如下图） Code Afterthought易错点: 直接向数组中加入元素，数组的静态初始化，举例：new int[]&#123;left, right&#125;； sum 与 target 的关系 &gt;、 &lt;、 == 连在一起成为一个整体，所以用 if.. else if.. else… 连起来，不要用三个 if； time complexity: O(n)，遍历一遍 nums； space complexity: O(1)；"},{"title":"剑指 Offer II 005. 单词长度的最大乘积","date":"2022-06-09T10:13:26.000Z","url":"/2022/06/09/jzii005/","tags":[["Bitwise","/tags/Bitwise/"],["Bitwise_Bit Shifting","/tags/Bitwise-Bit-Shifting/"],["Matrix","/tags/Matrix/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定一个字符串数组 words，请计算当两个字符串 words[i] 和 words[j] 不包含相同字符时，它们长度的乘积的最大值。假设字符串中只包含英语的小写字母。如果没有不包含相同字符的一对字符串，返回 0。 src： 例子： 注意 2 &lt;= words.length &lt;= 1000 1 &lt;= words[i].length &lt;= 1000 words[i] 仅包含小写字母 SolutionsSolution 1 (brute force，matrix)题目要求两个不重复的单词长度乘积最大，并返回该乘积。根据题意，单词 words[i] 仅包含小写字母，我们可以创造一个 matrix[words.length][26] 来记录，之后读表选取无相同字母的，并对其求积。 Work &amp; Thought（如下图） Code Afterthought易错点: 把字符串转变为一个新的 char 数组，toCharArray() for 循环可以缺少初始化语句、循环条件和每次循环更新语句 例如： for(; k &lt; 26; k++)&#123; time complexity: O(m * n2)，假设 m 为每个单词的平均长度，n 为 words 包含的单词数量； space complexity: O(n)； Solution 2 (bitwise)Solution 1 是把单词数组中的每个单词变成一个 entry，单个单词中的字母出现与否也占用一个维度，空间上可以再进行压缩。 Work &amp; Thought 如果将 26 个英文单词和 32 位的 int 联系起来，让单个单词中的字母占用一个 bit 位，0&#x2F;1 表示出现与否，就可以降维成一维 int 数组。 Code Afterthought易错点: binary 中放 1 用|，因为 OR 任意为 1 是 1，举例 mask[i] |= 1 &lt;&lt; 2，如果 mask[i] 原本是 001，就变为 101； 运算符优先级，== 优先于 &amp;，所以 (mask[i] &amp; mask[j]) == 0 的括号是必要的； time complexity: O(mn + n2)，假设 m 为每个单词的平均长度，n 为 words 包含的单词数量； space complexity: O(n)； 本方法与方法 1 思路差不多，就是需要熟悉位运算的一些操作。 Reference 文章图片来源 - hualuoyueque 链接： "},{"title":"剑指 Offer II 004. 只出现一次的数字","date":"2022-06-07T06:37:32.000Z","url":"/2022/06/07/jzii004/","tags":[["Bitwise","/tags/Bitwise/"],["Bitwise_Bit Shifting","/tags/Bitwise-Bit-Shifting/"],["Set","/tags/Set/"],["HashTable","/tags/HashTable/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给你一个整数数组 nums ，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 。请你找出并返回那个只出现了一次的元素。 src： 例子： 注意 1 &lt;&#x3D; nums.length &lt;&#x3D; 3 * 104 -231&lt;&#x3D; nums[i] &lt;&#x3D; 231 - 1 nums 中，除某个元素仅出现 一次 外，其余每个元素都恰出现 三次 进阶：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ SolutionsSolution 1 (数学方法，set)nums 除了目标元素只出现 1 次，剩余的每个元素都出现 3 次，那么可以利用 set 去重来做题。 Work &amp; ThoughtsumDistinct * 3 - sum &#x3D; target * 2； Code Afterthought易错点: 在计算 target 的值时，将会溢出 int 的边界，所以先放到 long 类型的变量里面； time complexity: O(n)，遍历 nums 数组； space complexity: O(n)，存放到 set 中占用的空间； Solution 2 (hashtable)nums 除了目标元素只出现 1 次，剩余的每个元素都出现 3 次，可以用 hashtable 来打表查表。 Work &amp; Thought用哈希表计数，先遍历数组放，后遍历哈希表查次数为1的key。 key value 数值 出现次数 Code Afterthought易错点: for each 的写法，关于遍历 hashmap（通过map.keySet()）； JDK 1.8 开始可以用 getOrDefault(key, default value)，在要赋默认值的场景下很好用； time complexity: O(n)，遍历 nums 数组； space complexity: O(n)，存放到 hashmap 中占用的空间； Solution 3 (bit wise, bit shifting)不占用额外的空间。 二进制的数，比如 1001，出现 3 次，若记录 1 出现的次数，为 3003，之后对其进行 mod 3 操作，就没有余数。 Work &amp; Thought根据题目，-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231- 1，我们可以创建一个 32 位长度的数组 cnt[]，用来记录所有数值的每一位共出现了多少次 1，之后对 cnt[] 数组的每一位进行 mod 3 操作，就可以得到只出现 1 次的值。 Code Afterthought 运算符的优先级 &gt;&gt; ， &amp; &gt;&gt; 优先于 &amp; ，所以(cur &gt;&gt; i) &amp; 1不加括号也对 % ，&amp; % 优先于 &amp;，也就是乘除优先于逻辑 &lt;&lt; ， += &lt;&lt; 优先于 += ，也就是位优先于赋值，所以ans += (1 &lt;&lt; i)不加括号也对 数每一位出现1的次数，可用移位cur &gt;&gt; i == 1 来实现； time complexity: O(n)，遍历 nums 数组； space complexity: O(1)，常数的空间申请； Solution 4 (bit wise, bit shifting optimazed)Work &amp; Thought根据题意，-231 &lt;&#x3D; nums[i] &lt;&#x3D; 231- 1，其实不用创建数组 cnt[]，一个 int 变量就可以，之后赋给返回结果 ans 即可。 int 是 32 位的，占用字节数 8 bit &#x3D; 4 byte，-231 &lt;&#x3D; cnt &lt;&#x3D; 231 - 1 Code Afterthoughttime complexity: O(n)，遍历 nums 数组； space complexity: O(1)，常数的空间申请； Reference 文章图片来源 - qingfengpython 链接： "},{"title":"剑指 Offer II 003. 前 n 个数字二进制中 1 的个数","date":"2022-06-06T13:42:09.000Z","url":"/2022/06/06/jzii003/","tags":[["Bitwise","/tags/Bitwise/"],["Bitwise_Bit Shifting","/tags/Bitwise-Bit-Shifting/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定一个非负整数 n ，请计算 0 到 n 之间的每个数字的二进制表示中 1 的个数，并输出一个数组。 src： 例子： 注意 0 &lt;= n &lt;= 105 进阶: 给出时间复杂度为 O(n*sizeof(integer)) 的解答非常容易。但你可以在线性时间 O(n) 内用一趟扫描做到吗？ 要求算法的空间复杂度为 O(n) 。 你能进一步完善解法吗？要求在C++或任何其他语言中不使用任何内置函数（如 C++ 中的 __builtin_popcount ）来执行此操作。 SolutionsSolution 1 (bit wise)i &amp; (i - 1) 可以消去最低位的 1 ，我们可以使用这种方法来计数。 Code Afterthought易错点: 运算符的优先级 &amp; and - - 优先于 &amp; ，所以这里i &amp; (i-1)可以没有括号； 数组的动态初始化，int[] c = new int[3]； time complexity: O(kn)， 假设计数时候的整数有k位； space complexity: O(1)； Solution 2 (iterate，bit wise optimazed)solution 1 是根据 i &amp; (i - 1) 可以消去最低位的 1 来计数，但需要对每一个数字（从 0-n）进行位数中的计数，是很浪费时间的。 Work &amp; Thought可以看出 i 和i &amp; (i - 1)的关联，即i 比i &amp; (i-1)多了一个最右边的1，举例，1110 比 1100 多一个1，也就是 14 比 12 多一个1。利用这点，就可以以小推大。 Code Afterthought易错点: 运算符的优先级 &amp; and - - 优先于 &amp; ，所以这里i &amp; (i-1)可以没有括号； 数组的动态初始化，int[] c = new int[3]； time complexity: O(n)； space complexity: O(1)； 迭代的思想。 Solution 3 (iterate，bit shifting，bit wise optimazed)如果要以小推大，就要建立起关联，我们可以发现，i 与 i &gt;&gt; 1 存在联系。 Work &amp; Thoughti 与 i &gt;&gt; 1存在联系： 如果 i 最低位为 0，即 i 为偶数，那么 i 与 i &gt;&gt; 1 二进制 1 的个数相同； 如果 i 最低位为 1，即 i 为奇数，那么 i 比 i &gt;&gt; 1 多一个1； 奇偶的判定：x &amp; 1，x 为偶数，结果为 0；x 为奇数，结果为 1； 那么，就可以列出式子：arr[i] = arr[i &gt;&gt; 1] + (i &amp; 1)； Code Afterthoughttime complexity: O(n)； space complexity: O(1)； 迭代的思想。 "},{"title":"剑指 Offer II 002. 二进制加法","date":"2022-06-06T07:06:05.000Z","url":"/2022/06/06/jzii002/","tags":[["Simulation","/tags/Simulation/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定两个 01 字符串 a 和 b ，请计算它们的和，并以二进制字符串的形式输出。 输入为 非空 字符串且只包含数字 1 和 0。 src： 例子： 注意 每个字符串仅由字符 &#39;0&#39; 或 &#39;1&#39; 组成。 1 &lt;= a.length, b.length &lt;= 10^4 字符串如果不是 &quot;0&quot; ，就都不含前导零。 SolutionsSolution 1 (brute force, simulation)题目要求实现加法，第一个想法是把传入参数直接加，但是是二进制，所以想到用模拟加法来做这道题（下图）。 Work &amp; Thought从右到左一位位地进行计算，把每一位的计算结果 append 到返回的结果 String（先放在可变字符串 StringBuilder），最后 reverse，也转成题目要求的 String。 指针 i，j 来指正在计算的位，读到的数据分别存到 digitA，digitB，输出结果存到 StringBuilder（可变，不同步）； 在逆序、返回结果前，记得把最后的 carry 加上； Code Afterthought易错点: i--，先引用后减去，即先让i所在的表达式中使用i的当前值，再让i减 1； 进位之后，记得 sum 要减去对应的进位，不然 sum 加到 result 上，后面就乱了； char 的 0、1 并不等同于 int 的 0、1，如果直接将 char 值 0 硬转为 int，得到的 int 值是 48，本题显然不是要 48，所以要减去 ‘0’； time complexity: O(max(M, N) )， 其中 M，N 为 a, b 数字长度，按位遍历一遍数字（以较长的数字为准）； space complexity: O(1)； 想到用模拟来做之后，思路清晰，这道题目还是很好写的，没什么难的。 "},{"title":"剑指 Offer II 001. 整数除法","date":"2022-05-31T12:46:28.000Z","url":"/2022/05/31/jzii001/","tags":[["Bitwise","/tags/Bitwise/"],["Simulation","/tags/Simulation/"],["Bitwise_Bit Shifting","/tags/Bitwise-Bit-Shifting/"]],"categories":[["Leetcode","/categories/Leetcode/"]],"content":"Introduce题干给定两个整数 a 和 b ，求它们的除法的商 a/b ，要求不得使用乘号 &#39;*&#39;、除号 &#39;/&#39; 以及求余符号 &#39;%&#39; 。 src： 例子： 注意 整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2； 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231−1]。本题中，如果除法结果溢出，则返回 231 − 1； -231 &lt;&#x3D; a, b &lt;&#x3D; 231 - 1； b !&#x3D; 0； SolutionsSolution 1 (brute force) 不进行模拟，也不进行位运算。直观。 题目要求a除以b的商，且截去小数部分，可以理解为 a 等价于 n * b + c（c &lt; b），用减法来实现乘法。 思想很简单，但是实现的时候要注意： 越界问题，int 类型的范围； 返回结果的正负号，计算的环境（正 or 负）； Work &amp; Thought 越界的讨论，本题是整数除法（c must &lt;&#x3D; a），所以溢出的情况只有一个，就是 −231 &#x2F; -1，它的结果 231 越界了，根据题目，需要特殊处理返回231 − 1； 还有一种情况，如果是在正数的计算环境中，a&#x3D;−231，a在转变成正数的时候，变成231，溢出了。所以，要么都变负数，要么特殊情况拎出来讨论。 结果的正负号，可以先记好，只有在它俩异号的时候商是负号，就是它俩一个负数 or 一个正数，用一个变量记下，之后统一计算的环境，进行计算； Code Afterthoughttime complexity: O( ) 难以具体地给出；space complexity: O(1)； 计算量太大，最坏情况如果a是 −231，b是 1，计算出商，需要算很多次。 在超时的边缘试探，leetcode 很难跑过。 特点是思路直观，因为 Java 语言的特点，需要考虑 int 越界这个因素，在结果输出和计算的时候都要考虑到这一点，是本题的难点。 Solution 2 (bit wise &amp; simulation)Work &amp; Thought 对于 int 越界问题，和 Solution 1 差不多的解法，先筛掉特殊情况，之后使用负数的计算环境； 如果要用正数计算环境，需要把传入的参数 a，b 强制转型为 long； 返回结果的正负号问题： 铺垫： 位运算的异或（不同是1）和与（同时为1是1），Integer.MIN_VALUE是负数，最高位为1； Integer.MIN_VALUE -2147483648 1-0000 0000 0000 0000 0000 0000 0000 000 a ^ b 解释：若a，b同号，0xxxx，若异号，1xxxx，这时和 Integer.MIN_VALUE 进行与运算，除了最高位，其它位均清0，得到结果 0（ab同号） or 1（ab异号）； 也可以这样：a ^ b &gt;&#x3D; 0，若大于0，就是异号，反之，就是同号，因为最高位是符号位； 相比于 Solution 1 的 flag，这个解法能体现位运算的知识储备。 simulation 部分：模拟除法的手写算式（二进制），本质还是减法，但是里面的一层用二进制，这样就可以用移位运算，省到log级别的时间复杂度。 Code Afterthoughttime complexity: O( logn) 难以具体地给出；space complexity: O(1)； 针对 int 越界的问题，用了 long，一些情况下可能会限制使用 long。 跑很快。 特点是移位运算，里面的一层循环要理清，算是难点。 商的正负号判断，相比于对 a，b 进行大于 0 小于 0 来说亮眼了，但是普通方法也是完全可以的。 Amended version of Solution2题目说我们的环境只能存储 32 位有符号整数，所以理论上，使用 long 是不被允许的。 位运算的环境改成 负数 就可以。 Code"},{"title":"Git 向导","date":"2021-05-04T21:40:14.000Z","url":"/2021/05/05/git-guide/","categories":[["Git","/categories/Git/"]],"content":"Git 是什么？Git 是一个分布式版本控制系统（Distributed Version Control System），客户端并不只提取最新版本的文件快照， 而是把代码仓库完整地镜像下来，包括完整的历史记录。 四个特点： 直接记录快照，而非差异比较； 近乎所有操作都是本地执行； Git 保证完整性； Git 一般只添加数据； Git 的工作流程 （Git - Workflow 来源：阮一峰的网络日志） 专业名词基本的 Git 工作流程： 在工作区（Workspace）中修改文件； 将更改选择性暂存至暂存区（Staging area&#x2F; Index）； 提交暂存区的内容到本地仓库（Repository）； Git 的三种状态，文件可能处于其一，假设这个文件是README.md，那么它为： modified：修改了文件，但修改仅在工作区； staged：将工作区已修改的文件放到了暂存区； committed：文件已经安全地保存到本地仓库。 配置 设置提交代码时的用户信息： 检查设定： 配置文件的路径： 本地仓库配置对应的配置文件路径 [–local] ： 用户全局配置对应的配置文件路径 [–global] ： 系统配置对应的配置文件路径[–system]： 新建代码库From existing data From existing repository注意：Git 克隆的是远程 Git 仓库的几乎所有数据，不仅仅是最新的版本。 本地变动 – git status列出哪些文件已被暂存、未被暂存、未被跟踪，即查看工作目录下的文件处于什么状态： 添加指定文件到暂存区，即将该文件放到暂存区（new file）： 也可以用上面的这条指令来暂存已被跟踪文件的最新修改（modified）； 如果对暂存后的文件再次进行修改，之后查询文件状态，那么这时，这个文件将会同时出现在 staging area 和 workspace，因为最新的修改还在工作区，没有暂存，而之前 git add 的版本被暂存了，如果这时提交，那么本地仓库的版本将会是最后一次 git add 的版本，不包含 workspace 中最新的修改。 本地变动 – git diff列出追踪但尚未暂存的文件更新了哪些部分，即工作区和暂存区的差异： 注意：git diff 不能显示自从上次提交的所有变化，它只能显示尚未暂存的变化。如果已经把所有修改的内容都暂存了，那么 git diff 不会有任何反馈。 列出已经暂存，但是没有提交到本地仓库的变化，即暂存区和上一个 commit 的差异： 列出工作区和上一个 commit 的差异（当前分支最新commit）： 列出两次 commit 之间的差异： 本地变动 – git add添加当前目录的所有文件到暂存区： 注意：如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。 对于同一个文件的多处变化，可以实现分次提交： 可以更好地利用 git commit 的注释功能，使仓库的版本颗粒度更高，可读性更好。 参考： stack overflow：Commit only part of a file in Git Git docs：git-add manpage 本地变动 – git rm删除工作区文件，并且将这次删除放入暂存区： 停止追踪指定文件，但该文件会保留在工作区： 比如删除添加.gitignore文件前错误提交的文件。 本地变动 – git mv移动文件，并将这个移动放入暂存区（也可以理解为文件改名）： 参考： Git docs：git-mv manpage 提交到本地仓库 – git commit提交暂存区到本地仓库： 也可以指定暂存区的文件提交到本地仓库，只要在 commit 后面指定 file。 跳过暂存区，直接将工作区自上次 commit 之后的变化，提交到本地仓库： 使用一次新的 commit，替代上一次提交： 重做上一次 commit，并包括指定文件的新变化： 参考： Git docs：git-commit manpage 提交到本地仓库 – git log列出当前分支的版本历史： 仅列出包含指定文件修改的 commit： 限制 log 的显示数量： 列出所有提交，每行显示一条 commit（仅显示提交的 hash 和 message）： 按提交者名字搜索并显示 commit： 按指定内容搜索并显示 commit： 显示图形化的 branch 信息： 参考： Git docs：git-log manpage 提交到本地仓库 – git reflog列出本地仓库的所有 commit： 提交到本地仓库 – git blame列出指定文件是什么人在什么时间修改过： 也可以具体查文档内部某一部分是谁修改： 参考： Git docs：git-blame manpage 远程仓库 – 拉取到本地拉取远程仓库的所有变动到本地，但不合并： 拉取远程仓库特定分支的更新到本地，不合并： 拉取远程仓库的所有变动到本地，之后自动与 HEAD 版本合并： 拉取远程仓库的所有变动到本地，并以 rebase 模式并入本地仓库： 列出当前配置的所有远程端： 如果远程仓库不止一个，那么就会全部列出，比如和多个协作者合作的，这样可以非常方便地拉取其他用户的贡献，还拥有向他们推送的权限。 显示某个远程端的信息： 增加一个新的远程仓库，并指定简写： 远程仓库 – 推送到远程上传本地指定分支到远程仓库： 注意：只有当有推送到该远程仓库的权限，及之前没有人推送过时，该命令才有效。如果有他人先推送到上游，那么，此时的推送命令就会被拒绝，必须先抓取他们的工作并将其合并到本地仓库，才能推送。 参考： Git book：remote branches 分支 – git branch列出本地仓库的所有分支： 列出所有远程分支： 列出所有本地分支和远程分支： 新建一个分支，但依然停留在当前分支： 新建一个分支，并切换到该分支： 新建一个分支，指向指定 commit： 新建一个分支，与指定的远程分支建立追踪关系： 建立追踪关系，在现有分支与指定的远程分支之间： 切换到指定分支，并更新工作区： 切换到上一个分支： 合并指定分支到当前分支： 选择一个 commit，合并进当前分支： 删除分支： 若该分支的修改尚未合并，那么用 -D 参数来强制删除分支，注意，该操作会丢失未合并的修改。 删除远程分支： 分支 – git rebase基于 base 对当前分支进行 rebase。base 可以是 commit、分支名称、tag 或者相对于 HEAD 的 commit。 参考： Git docs：git-rebase manpage B站视频：git-rebase 图解 回滚 – git revert新建一个 commit，用来撤销指定 commit，并且应用到当前分支： 回滚 – git checkout恢复暂存区的指定文件到工作区： 恢复某个 commit 的指定文件到暂存区和工作区： 恢复暂存区的所有文件到工作区： 回滚 – git reset重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变，即撤销这个文件上次的 git add： 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变： 重置暂存区与工作区，与上一次 commit 保持一致： 重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致： 重置当前HEAD为指定 commit，但保持暂存区和工作区不变： 暂时将未提交的变化移除，稍后再移入： 回滚 – 具体场景场景1. 已经提交内容到本地仓库 如何回滚？ 场景2. 修改了还未提交到暂存区 怎么撤销？ 补充： 一种是该文件自修改后还没有放到暂存区，那么，现在撤销修改，就是回到和版本库一模一样的状态； 另一种是该文件添加到暂存区后，又做了修改，那么现在撤销修改，就是回到添加到暂存区后的状态； 场景3. 提交到暂存区，但还未提交到本地仓库 怎么办？ 把暂存区的修改撤销（unstage），重新放回工作区。 所以， git reset 既可以回退版本，也可以把暂存区的修改回退到工作区。 之后，丢弃工作区的修改即可。 标签列出所有标签： 给当前版本打标签： 给指定 commit 打标签： 删除本地标签： 删除远程标签： 提交指定标签： 提交所有标签： 新建一个分支，指向某个标签： Git 的 GUI 工具SourceTreeSourceTree 官网 IntelliJ IDEA 中的 GitIntelliJ IDEA 官方文档 相关链接 Pro Git book by Scott Chacon and Ben Straub. The book is available online for free at git-scm.com&#x2F;book. 常用 Git 命令清单：阮一峰的网络日志. Git Cheat Sheet: made by Hylke Bons. Git Cheat Sheet 中文版: translated by Gevin. "},{"title":"categories","date":"2022-04-06T16:36:46.000Z","url":"/categories/index.html","categories":[[" ",""]]},{"title":"search","date":"2022-04-06T16:11:22.000Z","url":"/search/index.html","categories":[[" ",""]]},{"title":"tags","date":"2022-04-06T16:35:46.000Z","url":"/tags/index.html","categories":[[" ",""]]}]